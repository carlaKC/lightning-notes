# HTLC Interception

## Issue Writeup

https://github.com/lightningdevkit/rust-lightning/issues/2855

- LDK currently has the ability to intercept HTLCs that have "magic"
  SCID values (which belong to phantom payments), it would also
  be good to just provide regular interception.

Related issues:
- https://github.com/lightningdevkit/rust-lightning/issues/2320: reject
  HTLCs if running low on funds.
- https://github.com/lightningdevkit/rust-lightning/issues/2425: ability
  to add reputation algorithm.
  - Matt [notes](https://github.com/lightningdevkit/rust-lightning/issues/2425#issuecomment-1639046677)
    that we don't really want this handled via events (which users
    have to handle).
  - [Rather](https://github.com/lightningdevkit/rust-lightning/issues/2425#issuecomment-1648757397)
    it should be its own trait with sane defaults.
  - If the DOS-limiter allows a HTLC, it should still allow a
    [PendingHTLCsForwardable](https://github.com/lightningdevkit/rust-lightning/issues/2425#issuecomment-1684225186) event to be processed.
- https://github.com/lightningdevkit/rust-lightning/issues/2839:
  provides the option to externally provide a preimage for interception

## Draft PR

https://github.com/lightningdevkit/rust-lightning/pull/3843

There is a draft PR up that starts to address this issue. It needs
rebase and has been stale since 13 June. Some relevant points to
consider:
- [Concern](https://github.com/lightningdevkit/rust-lightning/pull/3843#issuecomment-2967983465)
  that a handler can block hot paths in LDK. Noted that the events
  approach could help with this.
- [Callback](https://github.com/lightningdevkit/rust-lightning/pull/3843#pullrequestreview-2924773696)
  to decide what to do with a HTLC later on seem to be required, no
  matter what approach is used.
- Suggestion to instead have a "do we want to intercept this"
  trait, and then use the existing interception logic.

## Existing Interception Logic

- There is a `HTLCIntercepted` event:
  - Currently generated for scids that are set using routing hints
  - Must be resolved with `forward_intercepted_htlc` or
    `fail_intercepted_htlc`
  - Also need to set `accept_intercept_htlcs` in your config to get
    these.
  - Contains the payment hash, next hop, inbound/outbound amount

Event creation:
- `forward_htlcs`:
  - Drain all pending forwards
  - If not our SCID 
  - We generate an interception ID
  - We add the HTLC to our pending intercepts

HTLC Forward:
- Get the alias of the peer that the outgoing channel belongs to
- Remove the HTLC from `pending_intercepted_htlcs`
- Create a HTLC to forward
- Individually call `forward_htlcs` with that single HTLC that we've
  freed

HTLC Fail:
- Gets the HTLC out of `pending_intercepted_htlcs`
- `fail_htlc_backwards_internal`
  - This is always called with `UnknownNextPeer`

## Designing a new interface

- Based on [this comment](https://github.com/lightningdevkit/rust-lightning/issues/2425#issuecomment-1684225186), it seems like the desire is to have a trait that would
implement DOS protections in LDK (independent of the interceptor).
- There's some need for a htlc interceptor to [block](https://github.com/lightningdevkit/rust-lightning/pull/3843#issuecomment-2963076191), which can be problematic for
  interception APIs.
- Callback architecture allows [not blocking the forwarding flow](https://github.com/lightningdevkit/rust-lightning/pull/3843#issuecomment-2969244910).
- Could also have a [should we intercept this](https://github.com/lightningdevkit/rust-lightning/pull/3843#pullrequestreview-2924773696) API?

### Design Considerations

Should this trait be implemented as a blocking handler or with queuing
and callbacks?
- We will be calling this trait at a performance-critical point in the
  codebase, so we can't tolerate any blocking operations.
- There is always a risk of externally implementations of the trait
  accidentally blocking.
- The queue itself if not at risk of denial of service because we only
  allow 483 HTLCs per channel.
- Queuing will be fast, and we can batch resolution to speed up
  operation.

-> Decision: this should be implemented with a queue and callback, like
   htlc interception is currently implemented in LDK.

Should this trait be called before or after the existing (and future
general) interception API?
- We should allow user-controlled interception APIs the opportunity to
  see all traffic, so that they can take custom actions on it.
  -> For example, intercepting a phantom receive will result in a
     custom action that results in our not needing to "forward" at all.
- We should be wary of DOS interception interfering with custom actions
  that the end user might want to take.
  -> For example, we intercept a htlc to make a JIT channel, only to
     fail it back due to DOS protections.
  - Options:
    - Add an `override_dos` option in regular interception
    - Implement awareness in our default impl (if possible)
    - Require custom implementation of DOS trait when taking custom
      actions

-> Decision: implement DOS trait after regular interception, and add
   awareness for custom use cases like JIT channels in default impl.

How should we handle the case where an implementation hangs/does not
give us a response for a HTLC?
- In the same way as we handle `pending_intercepted_htlcs` in
  `do_chain_event`; if we have not heard back from the impl then we
  fail it back.

What does this API look like?
- `should_forward_htlc`
- `htlc_resolved`

And then LDK's `ChannelManager` has a function that you call with your
outcomes from the trait to process them.
