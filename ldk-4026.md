# Add TxBuilder get_available_balances

The goal of this project is to allow an external builder to create our
commitment transactions, so that we could (in theory, still needs P2P)
add additional elements to our commitment transaction.

## Review Round 1

### Simplify calculation of the biggest HTLC value that can be sent next

Previously:
- `capacity_minus_commitment_fee_msat` was an i64 which we allowed to
  go into negative
  = `available_capacity_msat - max_reserved_commit_tx_fee_msat`
- `one_htlc_difference_msat` =
  `max_reserved_commit_tx_fee_msat - min_reserved_commit_tx_fee_msat`
  Which is the difference in fee rates when we have a non-dust vs
  dust htlc.
- We add this to our `capacity_minus_commitment_fee_msat`
- Set it to the minimum between itself and 1 sat below the dust limit

Now:
- `capacity_minus_commitment_fee_msat` is calculated with saturating
  sub, so would cap out at zero
- Provided that `real_dust_limit_timeout_sat` is always > 0 our check
  will always do the same thing.
- Instead of calcaulting the difference, we just calculate the two
  min/max feerates.

Q: is `real_dust_limit_timeout_sat` always > 0? Yes

In `get_available_balances_for_scope`:
We get our `max_reserved_commit_tx_fee_msat`:
- Next local commit fee, with a locally offered htlc that is above the
  dust limit (w/ fee spike buffer if necessary).

We get our `min_reserved_commit_tx_fee_msat`:
- Next local commit fee, with a locally offered htlc that is below the
  dust limit (w/ fee spike buffer if necessary).

If a non-dust HTLC would move our capacity under the dust limit,
then we'll switch to using our fee rate for a dust HTLC because we can't
send a non-dust HTLC. We then set our `available_capacity_msat` to the
smallest value between the dust limit and our capacity with the htlc
being dust (maybe the capacity is even less than the dust limit).

If a non-dust HTLC would not move our capacity under the dust limit,
we can just set our capacity to the amount available less the non-dust
HTLC fee.

### Introduce `TxBuilder::get_onchain_stats`

Q: [ ] What's the point in wrapping `OnChainStats` around
  `NextCommitmentStats`?
Q: [ ] Why do we want `get_onchain_stats` instead of
  `get_next_commitment_stats`?

### Delete TxBuilder::commit_tx_fee_sat

In `new_for_inbound_channel`, previously:
- We previously got our funding amount + subtracted non-htlc outputs
- We checked that their balance could pay for the commit fee
- Likewise, we checked that the remote balance less fee was above the
  required reserve.

Now:
- We `get_next_commitment_stats`, mapping the error to our funding
  amount error if it fails
- We check that remote balance can pay for the commitment fee
- We check that the counterparty meets reserve.

Q: Are we using the same feerate as before? Yes, we just also provide
   the dust limiting rate.

Q: [ ] How do we know this is the only error we can get here? 

In `new_for_outbound_channel`, previously:
- We did the reverse, checking that our local balance less non-htlc
  outputs could pay for the commit fee.

Now:
- We `get_next_commitment_stats` for the local commit, mapping the error
  to our funding amount error if that fails
- We check that our balance can cover the `commit_tx_fee_sat`

Briefly use `commit_tx_fee_sat` function which will be later deleted.

### f Remove debug assert on addl_nondust_htlc_count

0FC channels have a zero fee anyway, so it doesn't matter how many htlcs
we claim that we need to fit on the commitment. And in the world of
abstract commitments, we prob should make sure we can fit some.

### Delete TxBuilder::subtract_non_htlc_outputs

- Previously we'd call txbuilder.subtract_non_htlc_outputs, now we
  briefly move this to a function not on TxBuilder

In `TxBuilder`:
- Instead of `subtract_addl_outputs` we have `checked_sub_anchor_outputs`
- We also have `saturating_sub_anchor_outputs`, which does the same
  but saturating.
- We perform the checked sub as before in `get_next_commitment_stats`
- Use saturating sub as before in `build_commitment_transaction`

### Create `ChannelConstraints` to hold parameters for balance calcs

- Add helper functions to `get_{holder/counterparty}_channel_constraints`
- In `get_available_balances_for_scope` we use them, straightforward

### Extract dust exposure calculation in `tx_builder` to own function

- Pull dust calcs into their own function; same dust check on htlc
- [ ] Q: can get get rid of the option completely in
  `get_dust_exposure_stats`  if we're not using it?

### Rewrite `get_available_balances_for_scope` using `tx_builder` fns

Previously:
- We were manually creating candidate htlcs to get our min/max htlc
  feerates; now we can just calculate it w/ different counts on our

Now:
- Get all the HTLCs on our next commitment
- Apply a fee spike buffer to our feerate
- Get count of local htlcs that aren't dust
- Get max and min feerate for our commitment:
  - At most our current htlcs + spike buffer + extra
  - At least our current htlcs + spike buffer
  -> This is basically accounting for our next htlc being dust or not
- Get our total local dust exposure
- Get count of remote htlcs that aren't dust
- Calculate our balances less anchors
- Set our `outbound_capacity_msat` to local balance less reserve
- If we're paying fees:
  - Do same max available balance checks as before (dust considered)
  else:
  - 
Q: Why do we always add 1 to remote nondust htlc count to get fee?
- This is what we were previously doing, no fee spike but one extra htlc

Change: `pending_outbound_htlcs` are now from `get_next_commitment_htlcs`
- `local=false`: when we send a htlc, the remote is the first to validate
- `include_counterparty_unknown_htlcs=true`
- Inbound htlcs: include all htlcs except the ones that they've
  announced removal to us for.
- Outbound htlcs: include our announced, because we're including unknown,
  and all htlcs that they have removed (including those that they've
  removed from our commit).
- We also include our `holding_cell_htlcs` in `AddHTLC` state.

This is what we "reasonably" expect the remote to include; they won't
include stuff they've removed and we _might_ have added our "unknown"
htlcs (holding cells and announced) to their commitment once we get
our next commitment.

By contrast `get_pending_htlc_stats`:
- Would add all `pending_inbound_htlcs`
- Would add all `pending_outbound_htlcs`
- Would add holding cell items in `AddHTLC` state
-> We're just trimming down the htlcs that we actually consider here.

Q: Why are we always looking at the remote commitment?
- When we're sending a htlc, that's what's going to be validated by
  our counterparty checking the addition.

### Mv `ChannelContext::get_available_balances_for_scope` to `tx_builder`

Just a code move.

### Format `tx_builder::get_available_balances`

Just a formatting change. Feel like these should be in their original
commit, but not worth the nitpick.

### f: Explain why we take remote's view of pending HTLCs on `get_available_balances`

Adds a comment to previous commit.

### Multiply the feerate by the spike multiple in `can_accept_incoming_htlc`

What's the difference in multiplying the feerate rather than the fee?
- Our rounding to satoshis hits different (we previously would have
  rounded down to sats where we not don't).
- We can have a higher fee on our transaction, which means a lower
  amount of htlcs accepted possibly.

In `new_for_inbound_channel`:
- `get_next_remote_commitment_stats`
  - Now returns both stats and htlcs
- Removed our check that balance meets fee

In `new_for_outbound_channel`:
- Removed check that we meet the commitment fee

-> Commit fee checks are moved into `get_next_commitment_stats`

### Erase `get_pending_htlc_stats` in channel

Delete commit, nice.

### Return AvailableBalances in `get_onchain_stats`

- We now pass our constraints into calls for `get_onchain_stats`
- Naming is a bit weird

## Round 2

### Diff with Last Review

Old branch:
5a2bc9c5e..355d5ce89

New branch:
d2e2fbdee..b4c8b81a5

Diff:
- Rename to `ChannelStats` throughout the diff
- Renames `ChannelConstraints` to use the `holder_` prefix on dust limit
  and channel reserve, and the `counterparty_` prefix
- Consolidates `get_channel_constraints` into single call for channel
  (previously we had 2x fns).
- Fixes branching

Q: is this correct?
`counterparty_channel_reserve_satoshis: funding.holder_selected_channel_reserve_satoshis,`
- Yup, we appropriately switch it around where needed.

Q: we introduce `max_dust_htlc_exposure_msat` in channel.rs impl of
`ChannelContext` instead of using `counterparty_dust_limit_satoshis`
in a few places
- We pass this is as a param and get each side's dust based on that
  max exposure, rather than passing them in.

### Unwrap `get_available_balances` with no counterparty unknown htlcs

When not counting counterparty unknown htlcs:
- This will include htlcs that we have announced but the counterparty
  may not be considering yet.
- This will include any htlc adds in holding cells. 

When we don't do this:
- We're only considering htlcs that have been added to our channel
  state (and thus have been validated).

`get_available_balances_with_counterparty_unknown_htlcs`:
- Test function that includes unknown

`get_available_balances`:
- Gets available balances without unknown counterparty htlcs
- Unwraps because something has gone funko

### f: include counterparty unknown htlc in public balances calls

The fuzzer was sad that `send_htlc` didn't match
`get_available_balances` because the latter was more conservative (no
unknown htlcs included). This fixup updates `get_available_balances`
to also include unknown htlcs, with the downside that we've got
a higher chance of this call failing now.

Q: what happens when it fails (in callers)?
- `from_channel` gets channel balances an duses inbound/outbound
  capacity and htlc limit / htlc minimum.
- These are called in `list_channels_with_counterparty`,
  `list_funded_channels_with_filter` and `list_channels` (public
  facing).
- If we fail, we'll just wrap down to zero.
- This makes sense to be because we don't want to get our balances
  and then have them be different to what we can actually send because
  the sending logic is more conservative.

Why are there so many `get_available_balances` fns?
- `Channel.get_available_balances_internal`:
  - Called by `Channel.get_available_balances`
- `Channel.get_available_balances`:
  - Calls the internal w/ assert and fallback to zero balances.
  - Called by public API
- `FundedChannel.get_available_balances` 
  - Called by `send_htlc`
- `FundedChannel.get_available_balances_internal`:
  - Called by `Channel.get_available_balances_internal`
  - Called by `FundedChannel.get_available_balances`

Don't think we really need these 2 layers.
