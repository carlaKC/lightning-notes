# Trampoline Test Refactor

Q: Does LDK always have trampoline in the blinded tail?
- Yes, we include the final hop in our route and the
  `TrampolineHop` in the blinded tail of the route

When we have a payment, we create our packet using:
`create_payment_onion_internal` which will place our onion packets
inside of the onion payload.

What trampoline tests do we have in `blinded_payment_tests.rs`?
- `test_trampoline_single_hop_receive`
- `test_trampoline_unblinded_receive`

Each rely on helpers, running with success/failure of payment.

`test_trampoline_unblinded_receive`
  - `do_test_trampoline_unblinded_receive(true)`
    - Set up 3 nodes (A/B/C) with channels
    - Create a preimage set for C to receive
    - Manually create a path: Bob -> Carol
      - Add a blinded tail with a `TrampolineHop` to Carol
      - Add another blinded hop, which won't be used due to tramp
    - We fix the key for our sending node
    - Send the payment along the route
    - Create a replacement onion:
      - TODO - it's a receive
    - Pull the update from the first node and replace its onion
    - We then pass the payment along the path to the recipient 
    - Claim or fail the payment according to parameters

Q: need to understand the replacement onion in this test!!

`send_payment_with_route`:
- Takes a `Path` with `Vec<RouteHop>` and `Option<BlindedTail>`
- We call `send_payment` with a `FixedRouter` that uses our path
- `send_payment_for_non_bolt12_invoice`: 
  - `find_initial_route`: gets a single route from the options
  - `add_new_pending_payment`: creates privkeys for each hop
  - `pay_route_internal`:
    - Performs validation on the route's hops
    - `send_payment_along_path`: push each path, collect results
      - This is a closure that's passed along
    - Collect all results and return the success/failure of the payment

The closure that we provide this sending callstack is `ChannelManager`'s
`send_payment_along_path`:
- `create_payment_onion`:
  - `create_payment_onion_internal`:
    - If there is a blinded tail + trampoline hops:
      - `build_trampoline_onion_payloads`:
        - Add any blinded hops as `DirectEntry`
        - Use the `build_onion_payloads_callback`:
          - Pass the trampoline hops
          - Pass the `DirectEntry` hops 
          - Reverse the hops (last trampoline to first)
          - PushBack the blinded hop

      - `compute_trampoline_session_priv`:
      - `construct_trampoline_onion_keys`:
      - `construct_trampoline_onion_packet`:
      - Set `trampoline_packet_option` to `Some(TrampolineOnionPacket)` 

Go through this with our actual test route to make sense of it:
- Path:
  - hops { Bob, Carol }
  - blinded_tail: {
      trampoline_hops: { Carol },
      hops: { JunkKey }
  }

`create_payment_onion_internal`
- We have a blinded tail on the path
  - Blinded hops are not empty
    -  `build_trampoline_onion_payloads`:
      - `blinded_tail_with_hop_iter` = `blinded_tail.iter()`
        = { JunkKey }
      - `build_onion_payloads_callback`:
        `hops` = { Carol }
        `blinded_tail` = { JunkKey }
        - (0, Carol) = `hops.rev().enumerate()`
          - `idx == 0`
            - Matches on `BlindedTailDetails::DirectEntry`:
            - For (0, JunkKey}, push back blinded receive to this key
              - `PushBack` which pushes to our res as `BlindedReceive`
              - Add the final value to the total value
          - Add this hop's value to the total value
    - We have `trampoline_payloads` = `{ JunkKey }`
    - `construct_trampoline_onion_packet`
      `trampoline_payloads` = `{ JunkKey }` 
      Does the chacha-ing

`build_onion_payloads`:
  Full path passed in
  trampoline packet option with `Some{ JunkKey }` in it
  - We have a blinded tail and a trampoline packet, so we have
    `TrampolineEntry` with `trampoline_packet` = `{ Junk Key }`
  - Again, we call `build_onion_payloads_callback`:
    `hops` = regular hops in the path
    `blinded_tail_with_hop_iter` is the `trampoline_packet`

Iterate through our hops:
(0, Carol)
  - We're at the end, and we have a `blinded_tail` which is a
    `TrampolineEntry` so we `PushBack` it as a `TrampolineEntrypoint`
  - `last_hop_id` = Carol

(0, Bob)
  - We're not at the end of our hops, so we `PushForward` a `Forward`

```
res = 
Forward { Carol }
TrampolineEntryPoint { packet: JunkKey }
```

Finally, we construct our onion packet appropriately.

`BlindedTailDetails`:
- It's possible that we have a set of blinded hops and then a
  trampoline, or just a trampoline. We distinguish the following:
- `DirectEntry`: we have some regular hops before the trampoline.
- `TrampolineEntry`: we go directly to trampoline, with no blinding
  hops in between that and the regular node.

Taking this back to the test:
- We create an unblinded receive that goes inside of our trampoline
  packet, instead of the junk value that we started with
  (I believe this isn't supported due to privacy)
- We then wrap up the whole onion packet after the first hop
- This just simplifies the test I believe / allows us to test unblinded
  recipients.
