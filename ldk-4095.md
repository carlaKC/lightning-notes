# Trampoline Test Refactor

Q: Does LDK always have trampoline in the blinded tail?
- Yes, we include the final hop in our route and the
  `TrampolineHop` in the blinded tail of the route

When we have a payment, we create our packet using:
`create_payment_onion_internal` which will place our onion packets
inside of the onion payload.

What trampoline tests do we have in `blinded_payment_tests.rs`?
- `test_trampoline_single_hop_receive`
- `test_trampoline_unblinded_receive`

Each rely on helpers, running with success/failure of payment.

`test_trampoline_unblinded_receive`
  - `do_test_trampoline_unblinded_receive(true)`
    - Set up 3 nodes (A/B/C) with channels
    - Create a preimage set for C to receive
    - Manually create a path: Bob -> Carol
      - Add a blinded tail with a `TrampolineHop` to Carol
      - Add another blinded hop, which won't be used due to tramp
    - We fix the key for our sending node
    - Send the payment along the route
    - Create a replacement onion:
      - TODO - it's a receive
    - Pull the update from the first node and replace its onion
    - We then pass the payment along the path to the recipient 
    - Claim or fail the payment according to parameters

Q: need to understand the replacement onion in this test!!

`send_payment_with_route`:
- Takes a `Path` with `Vec<RouteHop>` and `Option<BlindedTail>`
- We call `send_payment` with a `FixedRouter` that uses our path
- `send_payment_for_non_bolt12_invoice`: 
  - `find_initial_route`: gets a single route from the options
  - `add_new_pending_payment`: creates privkeys for each hop
  - `pay_route_internal`:
    - Performs validation on the route's hops
    - `send_payment_along_path`: push each path, collect results
      - This is a closure that's passed along
    - Collect all results and return the success/failure of the payment

The closure that we provide this sending callstack is `ChannelManager`'s
`send_payment_along_path`:
- `create_payment_onion`:
  - `create_payment_onion_internal`:
    - If there is a blinded tail + trampoline hops:
      - `build_trampoline_onion_payloads`:
        - Add any blinded hops as `DirectEntry`
        - Use the `build_onion_payloads_callback`:
          - Pass the trampoline hops
          - Pass the `DirectEntry` hops 
          - Reverse the hops (last trampoline to first)
          - PushBack the blinded hop

      - `compute_trampoline_session_priv`:
      - `construct_trampoline_onion_keys`:
      - `construct_trampoline_onion_packet`:
      - Set `trampoline_packet_option` to `Some(TrampolineOnionPacket)` 

Go through this with our actual test route to make sense of it:
- Path:
  - hops { Bob, Carol }
  - blinded_tail: {
      trampoline_hops: { Carol },
      hops: { JunkKey }
  }

`create_payment_onion_internal`
- We have a blinded tail on the path
  - Blinded hops are not empty
    -  `build_trampoline_onion_payloads`:
      - `blinded_tail_with_hop_iter` = `blinded_tail.iter()`
        = { JunkKey }
      - `build_onion_payloads_callback`:
        `hops` = { Carol }
        `blinded_tail` = { JunkKey }
        - (0, Carol) = `hops.rev().enumerate()`
          - `idx == 0`
            - Matches on `BlindedTailDetails::DirectEntry`:
            - For (0, JunkKey}, push back blinded receive to this key
              - `PushBack` which pushes to our res as `BlindedReceive`
              - Add the final value to the total value
          - Add this hop's value to the total value
    - We have `trampoline_payloads` = `{ JunkKey }`
    - `construct_trampoline_onion_packet`
      `trampoline_payloads` = `{ JunkKey }` 
      Does the chacha-ing

`build_onion_payloads`:
  Full path passed in
  trampoline packet option with `Some{ JunkKey }` in it
  - We have a blinded tail and a trampoline packet, so we have
    `TrampolineEntry` with `trampoline_packet` = `{ Junk Key }`
  - Again, we call `build_onion_payloads_callback`:
    `hops` = regular hops in the path
    `blinded_tail_with_hop_iter` is the `trampoline_packet`

Iterate through our hops:
(0, Carol)
  - We're at the end, and we have a `blinded_tail` which is a
    `TrampolineEntry` so we `PushBack` it as a `TrampolineEntrypoint`
  - `last_hop_id` = Carol

(0, Bob)
  - We're not at the end of our hops, so we `PushForward` a `Forward`

```
res = 
Forward { Carol }
TrampolineEntryPoint { packet: JunkKey }
```

Finally, we construct our onion packet appropriately.

`BlindedTailDetails`:
- It's possible that we have a set of blinded hops and then a
  trampoline, or just a trampoline. We distinguish the following:
- `DirectEntry`: we have some regular hops before the trampoline.
- `TrampolineEntry`: we go directly to trampoline, with no blinding
  hops in between that and the regular node.

Taking this back to the test:
- We create an unblinded receive that goes inside of our trampoline
  packet, instead of the junk value that we started with
  (I believe this isn't supported due to privacy)
- We then wrap up the whole onion packet after the first hop
- This just simplifies the test I believe / allows us to test unblinded
  recipients.

`test_trampoline_single_hop_receive`:
- This test is simpler, because we don't need to "fake" add an unblinded
  trampoline receive.
- Create 3 nodes, connect with channels
- Create a blinded path to Carol
- Create route: Bob -> Carol -> Trampoline Carol
- Create and settle payment

Q: still need to go over the way we're using blinded paths/trampolines
in the `blinded_tail`, can't immediately picture what the route looks
like.

## Review Round 1

## Compute trampoline `session_priv` from `outer_session_priv`

- Previously, we'd use the `session_priv` to `create_payment_onion_internal`
- Now, we pass in the `outer_session_key`

The API has both:
- `session_priv`:
- `trampoline_session_priv_override`: is this is present, it's used as
  the `trampoline_session_priv`; if not it's calculated from
  `session_priv` (by hashing it)
- We never provide these overrides IRL, so we're always calculating
  from the outer onion

Q: is this in the specification?
- It just says that we have to use a different session key for the
  trampoline.
- It's okay to hash the outer session priv because we don't reveal
  that to our counterparty

Q: Why doesn't this change make a difference in the test?
- Previously we were hitting the override, and using the
  `outer_session_key` as our `trampoline_session_priv` (this isn't good
  because the specification says we should use different keys!)
- Now, we're using the `session_priv`

Changes to `create_payment_onion_internal`:

Before this commit:
- We would pass `session_priv` into `compute_trampoline_onion_keys`,
  it was the `session_priv` for the trampoline onion
- We had a `outer_session_priv_override`, which would be:
  - `secondary_session_priv` if `Some`
  - The hash of the `session_priv` if no secondary
- We use `outer_session_priv_override` to create our outer onion
  (if there was no trampoline, we just use the `session_priv` provided.
  -> This means that when there is a trampoline route, the `session_priv`
     would be for the inner onion, and when there wasn't it was for the
     outer onion, which is super confusing!

Now:
- We will use the `trampoline_session_priv_override` to 
  `compute_trampoline_onion_keys`, or hash the `session_priv` to get
  a trampoline secret
- We use `session_priv` to create our outer onion
-> This is much more consistent, when we have no trampoline we just
   use `session_priv`, and when we do have a trampoline we'll create a
   trampoline session priv from the outer one _if_ we don't have an
   override

Things I don't love here:
- Provide trampoline override together?
- debug assert that we don't provide the overrides when there is no
  trampoline tail?

## test_trampoline_unblinded_receive

- Previously:
  - We would create `carol_unblinded_tlvs`, and add then to a `path`
  - These would be used to create `carol_blinded_hops`, which is a
    real blinded path with real encrypted payload
  - Our test is switching out the final onion anyway, so we can just
    have junk encrypted data

- Now:
  - We just have junk data in the blinded hop
  - When we create our replacement onion:
    - We pull the `outer_session_priv` from our override randomness
    - We can calculate the `trampoline_session_priv`
  - We just overwrite the trampoline payloads

## Fix trampoline error packet encryption using trampoline shared secret

- There's an issue with error encryption when it happens in a trampoline
  hop
- Treating trampoline hops the same way as phantom

## Simplify test_trampoline_single_hop_receive

- Instead of switching out the onion receive, we just fail at the
  trampoline node to get the same outcome
