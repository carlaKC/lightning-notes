# Abstract weight of htlc transactions out of channel

This PR aims to move more of our "commitment related" logic
into `TxBuilder`. Specifically handling of HTLCs / dust concerns.

Right now, there are the following quite specific APIs:
- Success/timeout fees for second stage htlcs
- Total endogenous fees for the transaction

The question is whether we want these, or we can just pass all
our htlcs off to the builder and not worry about it. Specifically,
there are a few places that are pretty concerned with these values.

`get_pending_inbound_htlc_details`:
- Gets a `dust_buffer_feerate`
- Iterates through `pending_inbound_htlcs`:
  - Uses success dust limit + holder to get limit
  - Notes whether the htlc is dust

`get_pending_inbound_htlc_details`:
- Similar to the above, gets the dust limit and sets bool on
  htlcs.

Q: Is this `is_dust` bool used widely?
- This is persisted and publicly exposed
- They're really not used anywhere else
- Functions are only used in `from_channel`
  - Used in various list functions which seem mostly
    aesthetic

`get_available_balances_for_scope`:

If we are outbound:
- We create a candidate htlc that's above dust limit
- We create a candidate htlc that's below the dust limit
- We bump them by a multiplier if we need it 
- `capacity_minut_commitment_fee_msat` = 
  current balance minus the maximum commit fee
  - If this is less than the current dust threshold we can't
    add a non-dust htlc:
    - `capacity_minut_commitment_fee_msat` =
      available - max + max - min
    - Pick smallest value between dust limit and this amt
    - Available capacity is largest between leftover and real
  - Otherwise, we can add a non-dust htlc:
    - Our available capaity is what's in the channel

If we are not outbound:
- We get a htlc that's above the dust limit
- We get the next commit fee
- We cap to the available amount or the dust limit

Right now we pass in a `HTLCCandidate` to our fee calculations
and a `fee_spike_buffer`

## Revised Approach

Author notes:
- Goal is for tx builders to choose what they want to be dust (this is
  the focus of this PR)
- Getting everything out of channel is a higher level goal for the 
  series, which is being taken stepwise.
- `htlc_success_timeout_dust_limits` is only used in 
  `get_available_balances_for_scope` (maybe we can have something
  better for the "what's our balance" question?)
- We need to surface our second state tx fees so that we can calculate
  our dust exposure due to excess feerates
  - This is seeing whether we're having our tx fees blown up to over
    expose us to dust

### Add HTLCAmountDirection and let TxBuilder sort dust/nondust

TxBuilder changes:
- Add a `HTLCAmountDirection` struct that represents an "addable" htlc
  on the commitment (which is not yet added)
- `is_dust` accepts this type of htlc and performs a dust check
  - This needs to be used to calculate our total dust exposure
  - It's also used in various list-ey calls to set the `is_dust` field
- `commit_tx_fee_sat`: now accepts `addl_nondust_htlcs` which is just
  a count of extra htlcs that we want to include in the commitment
- `htlc_txs_endogenous_fees_sat`: ability to calculate the total
  fees on all of our thlcs.

## Review Round 3

Discussion since I last looked at this PR:
- [Matt](https://github.com/lightningdevkit/rust-lightning/pull/3921#discussion_r2220597448):
  Doesn't like passing list of HTLCs to `TxBuilder` and having it make
  decisions about dust, rather just provided the dust limit or have
  a query that says - hey what's this HTLC type?
- [Matt](https://github.com/lightningdevkit/rust-lightning/pull/3921#pullrequestreview-3048923631):
  Aim to have much smaller API with larger methods that provide
  "summary" reporting that can be used as caller sees fit (alla
  `build_commitment_stats`

### Add TxBuilder::get_next_commitment_stats

- There is a `HTLCAmountDirection` struct that allows us to specify
  the direction/msat of a specific HTLC
  - It has an `is_dust` impl on it that checks whether it is dust

Q: If we want people to be able to pick dust in `TxBuilder`, does this
  work?

- There is a `NextCommitmentStats` whch has:
  - HTLCS we'll include
  - Balances (if any)
  - Fees + dust exposure
  - Amount that we consider dust exposure if the remote has set an
    unreasonably high feerate (in our opinion) which is siphoning off
    large amounts to fees.
- This is surfaced by `get_next_commitment_stats` on the `TxBuidler`
  trait.
  - If zero fee commitment, can't have any `nondust_htlcs`
  - Subtract outbound from local, inbound from remote
  - `subtract_addl_outputs`:
    - subtracts additional outputs from balances (just anchors rn)
    - Whoever is outbound pays for balance

Q: Why does this take `nondust_htlcs` and `next_commitment_htlcs`?
   ie, what actually is `nondust_htlcs`?
- I think it's fee spike buffer stuff, but need to see more usages

Comparing `excess_fees_on_counterparty_tx_dust_exposure_msat` to the
inline code in `get_pending_htlc_stats`:

Channel:
- Count of offered non-dust htlcs:
  - pending_inbound_htlcs: above counterparty dust exposure
- Count of accepted non-dust htlcs:
  - pending_outbound_htlcs: above counterparty tx dust limit
  - holding_cell_htlc_updates: AwaitingACK and above counterparty
    dust tx limit
- Takes an `excess_feerate_opt`, which is the channel's fee rate excess
  above what we believe to be reasonable.
  - This is always Some when there are excess fees, and None when we're
    below the limiting feerate (so it doesn't matter).
- Get fees (vs our current exact amounts):
  - Commitment: one extra HTLC to what we have now
  - HTLCs: one extra accepted HTLC
- Dust exposure: dust on their commit + htlc/commit fees for "one more"
- Counterparty exposure: add any excess on our htlcs/commit for current
  set of htlcs

TxBuilder:
- We get the total count of our htlcs on the counterparty, accepted
  and offered:
  - Not dust / Counterparty commit (local = false)

Q: what do we pass in as next_commitment_htlcs?
- `get_next_commitment_htlcs`:
  - Intentionally makes some changes to the pending inbound/outbound
    HTLCs that we add
  - Still has the `AwaitingACK` holding cell as before

Q: what do we pass in as broadcaster_dust_limit_satoshios?
- This should be the counterparty's limit, but looks like it might
  be the holder commitment in some calling cases? 
  - This is ok, we only call this when _not_ generating local, which
    means that we'll only do so with the counterparty's feerate.

Q: What happens to the `pending_update_fee` that we use in our
   `excess_feerate_opt`?
- Seems missing?

### Add ChannelContext::get_next_{local, remote}_commitment_stats

Q: "in upcoming commits" in message - there are no commits in this PR?
- Probably just the next in the series?

TODO: resume on this!!
