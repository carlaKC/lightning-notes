# Abstract weight of htlc transactions out of channel

This PR aims to move more of our "commitment related" logic
into `TxBuilder`. Specifically handling of HTLCs / dust concerns.

Right now, there are the following quite specific APIs:
- Success/timeout fees for second stage htlcs
- Total endogenous fees for the transaction

The question is whether we want these, or we can just pass all
our htlcs off to the builder and not worry about it. Specifically,
there are a few places that are pretty concerned with these values.

`get_pending_inbound_htlc_details`:
- Gets a `dust_buffer_feerate`
- Iterates through `pending_inbound_htlcs`:
  - Uses success dust limit + holder to get limit
  - Notes whether the htlc is dust

`get_pending_inbound_htlc_details`:
- Similar to the above, gets the dust limit and sets bool on
  htlcs.

Q: Is this `is_dust` bool used widely?
- This is persisted and publicly exposed
- They're really not used anywhere else
- Functions are only used in `from_channel`
  - Used in various list functions which seem mostly
    aesthetic

`get_available_balances_for_scope`:

If we are outbound:
- We create a candidate htlc that's above dust limit
- We create a candidate htlc that's below the dust limit
- We bump them by a multiplier if we need it 
- `capacity_minut_commitment_fee_msat` = 
  current balance minus the maximum commit fee
  - If this is less than the current dust threshold we can't
    add a non-dust htlc:
    - `capacity_minut_commitment_fee_msat` =
      available - max + max - min
    - Pick smallest value between dust limit and this amt
    - Available capacity is largest between leftover and real
  - Otherwise, we can add a non-dust htlc:
    - Our available capaity is what's in the channel

If we are not outbound:
- We get a htlc that's above the dust limit
- We get the next commit fee
- We cap to the available amount or the dust limit

Right now we pass in a `HTLCCandidate` to our fee calculations
and a `fee_spike_buffer`

## Revised Approach

Author notes:
- Goal is for tx builders to choose what they want to be dust (this is
  the focus of this PR)
- Getting everything out of channel is a higher level goal for the 
  series, which is being taken stepwise.
- `htlc_success_timeout_dust_limits` is only used in 
  `get_available_balances_for_scope` (maybe we can have something
  better for the "what's our balance" question?)
- We need to surface our second state tx fees so that we can calculate
  our dust exposure due to excess feerates
  - This is seeing whether we're having our tx fees blown up to over
    expose us to dust

### Add HTLCAmountDirection and let TxBuilder sort dust/nondust

TxBuilder changes:
- Add a `HTLCAmountDirection` struct that represents an "addable" htlc
  on the commitment (which is not yet added)
- `is_dust` accepts this type of htlc and performs a dust check
  - This needs to be used to calculate our total dust exposure
  - It's also used in various list-ey calls to set the `is_dust` field
- `commit_tx_fee_sat`: now accepts `addl_nondust_htlcs` which is just
  a count of extra htlcs that we want to include in the commitment
- `htlc_txs_endogenous_fees_sat`: ability to calculate the total
  fees on all of our thlcs.

## Review Round 3

Discussion since I last looked at this PR:
- [Matt](https://github.com/lightningdevkit/rust-lightning/pull/3921#discussion_r2220597448):
  Doesn't like passing list of HTLCs to `TxBuilder` and having it make
  decisions about dust, rather just provided the dust limit or have
  a query that says - hey what's this HTLC type?
- [Matt](https://github.com/lightningdevkit/rust-lightning/pull/3921#pullrequestreview-3048923631):
  Aim to have much smaller API with larger methods that provide
  "summary" reporting that can be used as caller sees fit (alla
  `build_commitment_stats`

### Add TxBuilder::get_next_commitment_stats

- There is a `HTLCAmountDirection` struct that allows us to specify
  the direction/msat of a specific HTLC
  - It has an `is_dust` impl on it that checks whether it is dust

Q: If we want people to be able to pick dust in `TxBuilder`, does this
  work?

- There is a `NextCommitmentStats` whch has:
  - HTLCS we'll include
  - Balances (if any)
  - Fees + dust exposure
  - Amount that we consider dust exposure if the remote has set an
    unreasonably high feerate (in our opinion) which is siphoning off
    large amounts to fees.
- This is surfaced by `get_next_commitment_stats` on the `TxBuidler`
  trait.
  - If zero fee commitment, can't have any `nondust_htlcs`
  - Subtract outbound from local, inbound from remote
  - `subtract_addl_outputs`:
    - subtracts additional outputs from balances (just anchors rn)
    - Whoever is outbound pays for balance

Q: Why does this take `nondust_htlcs` and `next_commitment_htlcs`?
   ie, what actually is `nondust_htlcs`?
- I think it's fee spike buffer stuff, but need to see more usages

Comparing `excess_fees_on_counterparty_tx_dust_exposure_msat` to the
inline code in `get_pending_htlc_stats`:

Channel:
- Count of offered non-dust htlcs:
  - pending_inbound_htlcs: above counterparty dust exposure
- Count of accepted non-dust htlcs:
  - pending_outbound_htlcs: above counterparty tx dust limit
  - holding_cell_htlc_updates: AwaitingACK and above counterparty
    dust tx limit
- Takes an `excess_feerate_opt`, which is the channel's fee rate excess
  above what we believe to be reasonable.
  - This is always Some when there are excess fees, and None when we're
    below the limiting feerate (so it doesn't matter).
- Get fees (vs our current exact amounts):
  - Commitment: one extra HTLC to what we have now
  - HTLCs: one extra accepted HTLC
- Dust exposure: dust on their commit + htlc/commit fees for "one more"
- Counterparty exposure: add any excess on our htlcs/commit for current
  set of htlcs

TxBuilder:
- We get the total count of our htlcs on the counterparty, accepted
  and offered:
  - Not dust / Counterparty commit (local = false)

Q: what do we pass in as next_commitment_htlcs?
- `get_next_commitment_htlcs`:
  - Intentionally makes some changes to the pending inbound/outbound
    HTLCs that we add
  - Still has the `AwaitingACK` holding cell as before

Q: what do we pass in as broadcaster_dust_limit_satoshios?
- This should be the counterparty's limit, but looks like it might
  be the holder commitment in some calling cases? 
  - This is ok, we only call this when _not_ generating local, which
    means that we'll only do so with the counterparty's feerate.

Q: What happens to the `pending_update_fee` that we use in our
   `excess_feerate_opt`?
- Seems missing?

### Add ChannelContext::get_next_{local, remote}_commitment_stats

`get_next_commitment_htlcs`:
- Allocate `commitment_htlcs` to take maximum number of htlcs we
  could possibly have (plus one?)
Q: is the +1 for the HTLC candidate?

Q: what does include_counterparty_unknown_htlcs mean?

- Go through our htlcs and count them if they're going to be in the
  next commitment:
  - Pending inbound htlcs:
    - Any announced HTLC from the remote party will definitely be
      included (since it's in their view of pending htlcs)
    - If we've locally removed the HTLC:
      - If generating local commitment: we're waiting on them to
        remove this from out commitment, so we include it
      - If generating remote commitment: we've sent them a commitment
        signed which doesn't have this HTLC, so we won't include it
  - Pending outbound htlcs:
    - LocalAnnounced: we've sent them a commitment with this htlc,
      but they haven't yet revoked their commitment that _does not_
      have this htlc.
      - If they revoke next:
      - If the commitment signed next:
    - Committed: easy, it's locked in on both commits
    - RemoteRemoved:
      - If we're generating local commitment: they have removed it
        from our commitment (and sent us a commitment signed without
        it, so we won't include it).
      - If we're generating remote commitment: we haven't yet removed
        it from their commitment, so we'll include it.
    - AwaitingRemoteRevokeToRemote: they've sent us a commitment
      signed without this htlc, we haven't sent them a commitment
      without one yet. It's not in our commitment, and we're going
      to remove it from their next commitment.
    - AwaitingRemovedRemoteRevoke: we've sent them a commitment
      without this htlc, but we're waiting on their revoke and ack.
      It's already removed from our commitment, and we've sent them
      a commitmetn with out it (just need revoke)

```
  Node A (Local)                                    Node B (Remote)
  Outbound HTLC States                             Inbound HTLC States
  ┌─────────────────┐                             ┌─────────────────┐
  │                 │                             │                 │
  │ 1. Create HTLC  │                             │                 │
  │ ┌─────────────┐ │                             │                 │
  │ │LocalAnnoun- │ │──update_add_htlc──────────▶ │ ┌─────────────┐ │
  │ │ced          │ │                             │ │RemoteAnnoun-│ │ 1.Receive HTLC
  │ └─────────────┘ │                             │ │ced          │ │
  │                 │                             │ └─────────────┘ │
  │                 │                             │                 │
  │                 │◀────commitment_signed────── │ 2. Commit HTLC  │
  │                 │                             │ ┌─────────────┐ │
  │ 3. We must      │                             │ │AwaitingRem- │ │
  │    revoke       │                             │ │oteRevokeTo- │ │
  │                 │                             │ │Announce     │ │
  │                 │                             │ └─────────────┘ │
  │                 │                             │ (waiting for    │
  │                 │                             │  our revoke)    │
  │                 │                             │                 │
  │ ┌─────────────┐ │                             │                 │
  │ │  Committed  │ │──revoke_and_ack───────────▶ │                 │ 3.Got revoke,
  │ └─────────────┘ │                             │                 │  can now commit
  │                 │                             │                 │
  │                 │◀────commitment_signed────── │ 4. Include in   │
  │                 │                             │    our commit   │
  │                 │                             │ ┌─────────────┐ │
  │                 │──revoke_and_ack───────────▶ │ │AwaitingAnn- │ │ 4. Wait for our
  │                 │                             │ │ouncedRemote-│ │  revoke of
  │                 │                             │ │Revoke       │ │  their commit
  │                 │                             │ └─────────────┘ │
  │                 │                             │                 │
  │                 │◀────revoke_and_ack────────  │                 │ 5.Remote revokes
  │                 │                             │ ┌─────────────┐ │
  │                 │                             │ │  Committed  │ │ 5.HTLC locked
  │                 │                             │ └─────────────┘ │    in channel
  │                 │                             │                 │
  │ HTLC now locked in both commitments           │                 │
  │ ═══════════════════════════════════════════════════════════════ │
  │                 │                             │                 │
  │                 │                             │ 6a. Decide to   │
  │                 │                             │     fulfill OR  │
  │                 │◀──update_fulfill_htlc─────  │ 6b. Decide to   │
  │                 │     OR                      │     fail        │
  │                 │◀──update_fail_htlc────────  │                 │
  │ ┌─────────────┐ │                             │ ┌─────────────┐ │
  │ │RemoteRemoved│ │                             │ │LocalRemoved │ │ 6. Mark for
  │ └─────────────┘ │                             │ └─────────────┘ │ removal
  │                 │                             │                 │
  │                 │◀────commitment_signed────── │ 7. Commit the   │
  │                 │                             │    removal      │
  │ 7. Accept their │                             │                 │
  │    removal      │──revoke_and_ack───────────▶ │                 │
  │ ┌─────────────┐ │                             │                 │
  │ │AwaitingRem- │ │                             │                 │
  │ │oteRevokeTo- │ │                             │ 8. Wait for our │
  │ │Remove       │ │                             │    revoke, then │
  │ └─────────────┘ │                             │    they can     │
  │                 │                             │    finalize     │
  │                 │                             │                 │
  │ 8. Send our     │──commitment_signed────────▶ │                 │
  │    removal      │                             │                 │
  │ ┌─────────────┐ │                             │                 │
  │ │AwaitingRem- │ │                             │                 │
  │ │ovedRemote-  │ │                             │                 │
  │ │Revoke       │ │                             │                 │
  │ └─────────────┘ │                             │                 │
  │                 │                             │                 │
  │                 │◀────revoke_and_ack────────  │ 9. Final revoke │
  │                 │                             │                 │
  │ 9. HTLC fully   │                             │ HTLC completely │
  │    removed      │                             │ removed from    │
  │    from state   │                             │ state           │
  │                 │                             │                 │
  └─────────────────┘                             └─────────────────┘
```
For holding cell HTLCS:
- We only include HTLCs that are added (not removed ones) 

`get_next_commitment_value_to_self_msat`
- Gets all the htlcs that are "coming back" to our commitment 

Q: is this just the opposite of the previous function?
/ Could we pass in a bool for (added/removed) and then handle
- Not really, we're concerned with the specific removal reason
  in this function 

`pending_inbound_htlcs`:
- LocalRemoved / Fulfilled:
  - We have sent them an update_fulfill_htlc, the htlc is committed
    on both of our txns
  - We're next going to send them a commitment _without_ this htlc,
    so when dealing with the remote commitment we can count this
    towards our balance.
  - When they send us our next commitment, the presence of this HTLC
    depends on ordering: if they happen to send us a commitment signed
    with some other htlc that they added that still included this one,
    it'll still be there.

`pending_outbound_htlcs`:
- RemoteRemoved: we have received an update_fail_htlc to remove this
  HTLC from their commitment
- AwaitingRemoteRevokeToRemote/AwaitingRemovedRemoteRevoke:
  - We only have a commitment that does not contain this HTLT
    (we have revoked the one that had it).
  - The next commitment we send them will not have this htlc.

## Review Round 4

### Add TxBuilder::get_next_commitment_stats

- Has been rebased to use `second_stage_tx_fees`, so will be correct
  for V3 channels
- `pending_update_fee` will just be pased in as `feerate_per_kw`

Q: When we're (currently) dealing with `pending_update_fee`, do we
  *only* use the pending rate in all the relevant calculations?
  - In `get_pending_htlc_stats` we only use the pending feerate, so
    just passing in will work

### Adjust dust exposure due to excess fees for clarity

- Removes the mutable variable, does some renames

### Add ChannelContext::get_next_{local, remote}_commitment_stats

- Unchanged from last review (checked diff)

### Improve prediction of commitment stats in validate_update_add_htlc

Q: Why does the `pending_inbound_htlcs` +1 > `self.holder_max_accepted_htlcs`
   change to `inbound_htlcs_count` > `self.holder_max_accepted_htlcs`?
- Previously: we used `get_pending_htlc_stats` which would over-count
  the number of HTLCs that we're actually going to have
- This is because we provide a HTLC candidate that will be counted,
  and its amount added

Q: Are all of our checked subs okay? Ie, could somebody send us a too
   bit htlc candidate which we validate and then crash?
  - `update_add_htlc`:
    - `validate_update_add_htlc`:
      - `get_next_remote_commitment_stats` with `Some(proposed_amt)`:
        - `get_next_commitment_htlcs`: will push candidate
          - `next_commitment_htlcs` contains (outbound: false, amount)
        - `get_next_commitment_stats` with `next_commitment_htlcs`:
          - Seems like we can hit the expect

Going to resume after crash question is addressed, as it may result in
changes / might apply to other commits that follow this one. If I'm
wrong, need to take an even-closer look at this code.

## Review Round 4+

Picking up review after crash bug has been addressed - fixups just
allow balances to be `None` and leave it to the caller to deal with
it.

There's also a fixup that includes the addl htlc in our total count.
This is usually a fee spike buffer htlc?

### Improve prediction of commitment stats in validate_update_add_htlc

Previously:
- `get_pending_htlc_stats(None, dust_exposure_limiting_feerate)`
  - If pending inbound +1 > holder_max_accepted_htlcs
  - If pending amt + htlc amt > max in flight
- To get our balances:
  - Sum up all the removed outbound
  - Sum up all the added inbound
  - Take off the additional outputs from these pending values 
  - If what we have left is less than the amount, fail
- To make sure they can afford this htlc on the remote commitment:
  - Create a candidate htlc that's been offered
  - Get our commit fee with the candidate
  - Check that their balance is > reserve plus fee
- To make sure they can afford the htlc on the local commitment:
  - Create a htlc candidate offered by the remote peer
  - Get local commit fee
  - Check that balance > reserve + fee

Now:
- We do not include a fee spike buffer htlc, `get_pending_htlc_stats`
  didn't either
- We pass our htlc as an additional to the tx builder (with its
  direction and amount)
  - We can just check the total amount of htlcs, don't need the +1
  - Likewise, we can just check the total amount on the commitment
- We get their balance, failing the htlc if the balance - htlcs would
  be None
- Get local commitment stats with no fee spike htlc or additiaonl
- We check that holder balance > reserve + fee

### Improve prediction of commitment stats in can_accept_incoming_htlc

- When we call `can_accept_incoming_htlc`, we're in 
  `process_pending_update_add_htlcs` so the htlc is already on the
  channel's state.

Previously:
- Call `get_pending_htlc_stats`
  - Check that their dust exposure is under the maximum
  - We check holder and counterparty  
- When they are responsible for fees:
  - Get the remote commitment fee and check that they can pay for it

Now:
- We get both local and remote commitment stats
  - We check that their dust exposure is below the max
  - We check that our dust exposure is below the max
    - The htlc-specific calculations have already been done in txbuilder
- When they are responsible for fees:
  - Get the remote commitment fee and check they can pay for it
- We no longer have to pass the htlc through to this function
  because we're now appropriately collecting all of the htlcs we need
  straight from source

### Improve prediction of commitment stats in validate_update_fee

Previously:
- `get_pending_htlc_stats`

Now:
- Get both local and remote commitment stats
- Check that htey're not over the dust exposure

### Improve prediction of commitment stats in can_send_send_update_fee

Previously:
- `build_commitment_stats (local=true, generated_by_local=true)`
  - We use the holder's dust limit 
  - We look at success tx fee for dust
  - This impacts the fee, as we're using the `non_dust_htlc_count`
    to calculate the `commit_tx_fee_sat`

Now:
- Get `next_remote_commitment_stats(local=false)`
  - Gets the stats for the remote party's commitment
  - As it will be held by them 

Q: seems like we've switched to looking at the remote commitment
  rather than the local one? Do we need both?

Overall:
- Seems not amazing that the changes to the htlcs that we select
  didn't break any tests?
- But perhaps we were only testing the "obvious" state cases, and the
  ones that we're now cutting out are always weird pending things
