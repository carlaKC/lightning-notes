# Abstract weight of htlc transactions out of channel

This PR aims to move more of our "commitment related" logic
into `TxBuilder`. Specifically handling of HTLCs / dust concerns.

Right now, there are the following quite specific APIs:
- Success/timeout fees for second stage htlcs
- Total endogenous fees for the transaction

The question is whether we want these, or we can just pass all
our htlcs off to the builder and not worry about it. Specifically,
there are a few places that are pretty concerned with these values.

`get_pending_inbound_htlc_details`:
- Gets a `dust_buffer_feerate`
- Iterates through `pending_inbound_htlcs`:
  - Uses success dust limit + holder to get limit
  - Notes whether the htlc is dust

`get_pending_inbound_htlc_details`:
- Similar to the above, gets the dust limit and sets bool on
  htlcs.

Q: Is this `is_dust` bool used widely?
- This is persisted and publicly exposed
- They're really not used anywhere else
- Functions are only used in `from_channel`
  - Used in various list functions which seem mostly
    aesthetic

`get_available_balances_for_scope`:

If we are outbound:
- We create a candidate htlc that's above dust limit
- We create a candidate htlc that's below the dust limit
- We bump them by a multiplier if we need it 
- `capacity_minut_commitment_fee_msat` = 
  current balance minus the maximum commit fee
  - If this is less than the current dust threshold we can't
    add a non-dust htlc:
    - `capacity_minut_commitment_fee_msat` =
      available - max + max - min
    - Pick smallest value between dust limit and this amt
    - Available capacity is largest between leftover and real
  - Otherwise, we can add a non-dust htlc:
    - Our available capaity is what's in the channel

If we are not outbound:
- We get a htlc that's above the dust limit
- We get the next commit fee
- We cap to the available amount or the dust limit

Right now we pass in a `HTLCCandidate` to our fee calculations
and a `fee_spike_buffer`

## Revised Approach

Author notes:
- Goal is for tx builders to choose what they want to be dust (this is
  the focus of this PR)
- Getting everything out of channel is a higher level goal for the 
  series, which is being taken stepwise.
- `htlc_success_timeout_dust_limits` is only used in 
  `get_available_balances_for_scope` (maybe we can have something
  better for the "what's our balance" question?)
- We need to surface our second state tx fees so that we can calculate
  our dust exposure due to excess feerates
  - This is seeing whether we're having our tx fees blown up to over
    expose us to dust

### Add HTLCAmountDirection and let TxBuilder sort dust/nondust

TxBuilder changes:
- Add a `HTLCAmountDirection` struct that represents an "addable" htlc
  on the commitment (which is not yet added)
- `is_dust` accepts this type of htlc and performs a dust check
  - This needs to be used to calculate our total dust exposure
  - It's also used in various list-ey calls to set the `is_dust` field
- `commit_tx_fee_sat`: now accepts `addl_nondust_htlcs` which is just
  a count of extra htlcs that we want to include in the commitment
- `htlc_txs_endogenous_fees_sat`: ability to calculate the total
  fees on all of our thlcs.

## Review Round 3

Discussion since I last looked at this PR:
- [Matt](https://github.com/lightningdevkit/rust-lightning/pull/3921#discussion_r2220597448):
  Doesn't like passing list of HTLCs to `TxBuilder` and having it make
  decisions about dust, rather just provided the dust limit or have
  a query that says - hey what's this HTLC type?
- [Matt](https://github.com/lightningdevkit/rust-lightning/pull/3921#pullrequestreview-3048923631):
  Aim to have much smaller API with larger methods that provide
  "summary" reporting that can be used as caller sees fit (alla
  `build_commitment_stats`

### Add TxBuilder::get_next_commitment_stats

- There is a `HTLCAmountDirection` struct that allows us to specify
  the direction/msat of a specific HTLC
  - It has an `is_dust` impl on it that checks whether it is dust

Q: If we want people to be able to pick dust in `TxBuilder`, does this
  work?

- There is a `NextCommitmentStats` whch has:
  - HTLCS we'll include
  - Balances (if any)
  - Fees + dust exposure
  - Amount that we consider dust exposure if the remote has set an
    unreasonably high feerate (in our opinion) which is siphoning off
    large amounts to fees.
- This is surfaced by `get_next_commitment_stats` on the `TxBuidler`
  trait.
  - If zero fee commitment, can't have any `nondust_htlcs`
  - Subtract outbound from local, inbound from remote
  - `subtract_addl_outputs`:
    - subtracts additional outputs from balances (just anchors rn)
    - Whoever is outbound pays for balance

Q: Why does this take `nondust_htlcs` and `next_commitment_htlcs`?
   ie, what actually is `nondust_htlcs`?
- I think it's fee spike buffer stuff, but need to see more usages

Comparing `excess_fees_on_counterparty_tx_dust_exposure_msat` to the
inline code in `get_pending_htlc_stats`:

Channel:
- Count of offered non-dust htlcs:
  - pending_inbound_htlcs: above counterparty dust exposure
- Count of accepted non-dust htlcs:
  - pending_outbound_htlcs: above counterparty tx dust limit
  - holding_cell_htlc_updates: AwaitingACK and above counterparty
    dust tx limit
- Takes an `excess_feerate_opt`, which is the channel's fee rate excess
  above what we believe to be reasonable.
  - This is always Some when there are excess fees, and None when we're
    below the limiting feerate (so it doesn't matter).
- Get fees (vs our current exact amounts):
  - Commitment: one extra HTLC to what we have now
  - HTLCs: one extra accepted HTLC
- Dust exposure: dust on their commit + htlc/commit fees for "one more"
- Counterparty exposure: add any excess on our htlcs/commit for current
  set of htlcs

TxBuilder:
- We get the total count of our htlcs on the counterparty, accepted
  and offered:
  - Not dust / Counterparty commit (local = false)

Q: what do we pass in as next_commitment_htlcs?
- `get_next_commitment_htlcs`:
  - Intentionally makes some changes to the pending inbound/outbound
    HTLCs that we add
  - Still has the `AwaitingACK` holding cell as before

Q: what do we pass in as broadcaster_dust_limit_satoshios?
- This should be the counterparty's limit, but looks like it might
  be the holder commitment in some calling cases? 
  - This is ok, we only call this when _not_ generating local, which
    means that we'll only do so with the counterparty's feerate.

Q: What happens to the `pending_update_fee` that we use in our
   `excess_feerate_opt`?
- Seems missing?

### Add ChannelContext::get_next_{local, remote}_commitment_stats

`get_next_commitment_htlcs`:
- Allocate `commitment_htlcs` to take maximum number of htlcs we
  could possibly have (plus one?)
Q: is the +1 for the HTLC candidate?

Q: what does include_counterparty_unknown_htlcs mean?

- Go through our htlcs and count them if they're going to be in the
  next commitment:
  - Pending inbound htlcs:
    - Any announced HTLC from the remote party will definitely be
      included (since it's in their view of pending htlcs)
    - If we've locally removed the HTLC:
      - If generating local commitment: we're waiting on them to
        remove this from out commitment, so we include it
      - If generating remote commitment: we've sent them a commitment
        signed which doesn't have this HTLC, so we won't include it
  - Pending outbound htlcs:
    - LocalAnnounced: we've sent them a commitment with this htlc,
      but they haven't yet revoked their commitment that _does not_
      have this htlc.
      - If they revoke next:
      - If the commitment signed next:
    - Committed: easy, it's locked in on both commits
    - RemoteRemoved:
      - If we're generating local commitment: they have removed it
        from our commitment (and sent us a commitment signed without
        it, so we won't include it).
      - If we're generating remote commitment: we haven't yet removed
        it from their commitment, so we'll include it.
    - AwaitingRemoteRevokeToRemote: they've sent us a commitment
      signed without this htlc, we haven't sent them a commitment
      without one yet. It's not in our commitment, and we're going
      to remove it from their next commitment.
    - AwaitingRemovedRemoteRevoke: we've sent them a commitment
      without this htlc, but we're waiting on their revoke and ack.
      It's already removed from our commitment, and we've sent them
      a commitmetn with out it (just need revoke)

```
  Node A (Local)                                    Node B (Remote)
  Outbound HTLC States                             Inbound HTLC States
  ┌─────────────────┐                             ┌─────────────────┐
  │                 │                             │                 │
  │ 1. Create HTLC  │                             │                 │
  │ ┌─────────────┐ │                             │                 │
  │ │LocalAnnoun- │ │──update_add_htlc──────────▶ │ ┌─────────────┐ │
  │ │ced          │ │                             │ │RemoteAnnoun-│ │ 1.Receive HTLC
  │ └─────────────┘ │                             │ │ced          │ │
  │                 │                             │ └─────────────┘ │
  │                 │                             │                 │
  │                 │◀────commitment_signed────── │ 2. Commit HTLC  │
  │                 │                             │ ┌─────────────┐ │
  │ 3. We must      │                             │ │AwaitingRem- │ │
  │    revoke       │                             │ │oteRevokeTo- │ │
  │                 │                             │ │Announce     │ │
  │                 │                             │ └─────────────┘ │
  │                 │                             │ (waiting for    │
  │                 │                             │  our revoke)    │
  │                 │                             │                 │
  │ ┌─────────────┐ │                             │                 │
  │ │  Committed  │ │──revoke_and_ack───────────▶ │                 │ 3.Got revoke,
  │ └─────────────┘ │                             │                 │  can now commit
  │                 │                             │                 │
  │                 │◀────commitment_signed────── │ 4. Include in   │
  │                 │                             │    our commit   │
  │                 │                             │ ┌─────────────┐ │
  │                 │──revoke_and_ack───────────▶ │ │AwaitingAnn- │ │ 4. Wait for our
  │                 │                             │ │ouncedRemote-│ │  revoke of
  │                 │                             │ │Revoke       │ │  their commit
  │                 │                             │ └─────────────┘ │
  │                 │                             │                 │
  │                 │◀────revoke_and_ack────────  │                 │ 5.Remote revokes
  │                 │                             │ ┌─────────────┐ │
  │                 │                             │ │  Committed  │ │ 5.HTLC locked
  │                 │                             │ └─────────────┘ │    in channel
  │                 │                             │                 │
  │ HTLC now locked in both commitments           │                 │
  │ ═══════════════════════════════════════════════════════════════ │
  │                 │                             │                 │
  │                 │                             │ 6a. Decide to   │
  │                 │                             │     fulfill OR  │
  │                 │◀──update_fulfill_htlc─────  │ 6b. Decide to   │
  │                 │     OR                      │     fail        │
  │                 │◀──update_fail_htlc────────  │                 │
  │ ┌─────────────┐ │                             │ ┌─────────────┐ │
  │ │RemoteRemoved│ │                             │ │LocalRemoved │ │ 6. Mark for
  │ └─────────────┘ │                             │ └─────────────┘ │ removal
  │                 │                             │                 │
  │                 │◀────commitment_signed────── │ 7. Commit the   │
  │                 │                             │    removal      │
  │ 7. Accept their │                             │                 │
  │    removal      │──revoke_and_ack───────────▶ │                 │
  │ ┌─────────────┐ │                             │                 │
  │ │AwaitingRem- │ │                             │                 │
  │ │oteRevokeTo- │ │                             │ 8. Wait for our │
  │ │Remove       │ │                             │    revoke, then │
  │ └─────────────┘ │                             │    they can     │
  │                 │                             │    finalize     │
  │                 │                             │                 │
  │ 8. Send our     │──commitment_signed────────▶ │                 │
  │    removal      │                             │                 │
  │ ┌─────────────┐ │                             │                 │
  │ │AwaitingRem- │ │                             │                 │
  │ │ovedRemote-  │ │                             │                 │
  │ │Revoke       │ │                             │                 │
  │ └─────────────┘ │                             │                 │
  │                 │                             │                 │
  │                 │◀────revoke_and_ack────────  │ 9. Final revoke │
  │                 │                             │                 │
  │ 9. HTLC fully   │                             │ HTLC completely │
  │    removed      │                             │ removed from    │
  │    from state   │                             │ state           │
  │                 │                             │                 │
  └─────────────────┘                             └─────────────────┘
```
For holding cell HTLCS:
- We only include HTLCs that are added (not removed ones) 

`get_next_commitment_value_to_self_msat`
- Gets all the htlcs that are "coming back" to our commitment 

Q: is this just the opposite of the previous function?
/ Could we pass in a bool for (added/removed) and then handle
- Not really, we're concerned with the specific removal reason
  in this function 

`pending_inbound_htlcs`:
- LocalRemoved / Fulfilled:
  - We have sent them an update_fulfill_htlc, the htlc is committed
    on both of our txns
  - We're next going to send them a commitment _without_ this htlc,
    so when dealing with the remote commitment we can count this
    towards our balance.
  - When they send us our next commitment, the presence of this HTLC
    depends on ordering: if they happen to send us a commitment signed
    with some other htlc that they added that still included this one,
    it'll still be there.

`pending_outbound_htlcs`:
- RemoteRemoved: we have received an update_fail_htlc to remove this
  HTLC from their commitment
- AwaitingRemoteRevokeToRemote/AwaitingRemovedRemoteRevoke:
  - We only have a commitment that does not contain this HTLT
    (we have revoked the one that had it).
  - The next commitment we send them will not have this htlc.
