# Trampoline Prefactor

Note: opening a new doc for the open PR, lots of notes are in
ldk-trampoline.md.

## Review Round 1 (Matt)

### ln/events: multiple htlcs in/out for trampoline PaymentForwarded

- [x] Need to write values in `PaymentForwarded` w/ one HTLC
  I think we should just always write the legacy field then. Because
  we could have a one-in-one out trampoline payment which would look
  like a regular payment, but the event will have the wrong fees.
  We'll fail to downgrade elsewhere if we have trampoline in flight,
  so I think it's fine to keep the complication.

- [x] No opinion on use of `default_value`
  Went with always writing legacy and it's fine.

- [x] Should we `Err` in the else branches for these then?
  Outdated, but also no because we could _not_ have the legacy field
  persisted for newer events in that version of it.

### ln: make event optional in EmitEventAndFreeOtherChannel

- [x] Move into pending changelog: done

### ln+events: allow multiple prev_channel_id in HTLCHandlingFailed

- [x] Definitely need to persist old channel id value

### ln: add TrampolineForward variant to HTLCSource enum
 
- [x] What about the blinded tail we're paying to? For blinded errors?
Response: Indeed, should be `Path`, was missing in the dependent PR.

- [x] Can we use `init_and_real_tlv_fields` for `HTLCSource`?
   This doesn't exist, but moved to using macros.

Q: do we need to have `impl_for_vec`?
- Yes, to be able to write the whole vec

### ln: add trampoline routing payment claiming

- [On startup reconciliation for payments (like we have for MPP)](#mpp-claim-logic)

#### MPP Claim Logic

On restart, we'll read all of our pending outbound htlcs from the
channelmanager and add them to `pending_claims_to_replay`. We then
call `claim_funds_internal` to re-process preimage for the incoming
HTLCs. This will report the HTLC success to trampoline outbound tracking
and claim the incoming HTLC.

#### Incoming MPP Collection

The logic that we need to claim MPPs at restart (Matt's comment) is
likely the same as that which we need to allow them to accumulate on
the incoming link.

- We have a map of `claimable_payments` which has things that we can
  claim, and `pending_claiming_payments` which we have begun to
  claim but need to update the `ChannelMonitorUPdate` to notify the
  user.
- These maps are created as empty maps when we produce a new
  `ChannelManager`, and written/read after that.
- In our `timer_tick_occurred` map, we have logic to time out MPP
  payments.
- We also have a check in `do_chain_event` that will time out our
  outgoing htlcs if they're about to time out.
- We call `begin_claiming_payment` in `claim_payment_internal`
  - This is where we add it to `pending_claiming_payments`
  - We remove once `handle_monitor_update_completion_actions` is done

Q: How would handling both incoming and outgoing happen?
- We currently have handling of our trampoline forwards in
  `process_receive_htlcs`
- Current approach goes straight to `send_payment_for_trampoline_payment`
  which is wrong, because we'll forward out the outgoing amount before
  we know we've received the full amount.
- Instead, we should also add to `claimable_payments`, and allow all of
  the same logic to apply. But now we also need to know:
  - When to dispatch the payment (ie, everything is there)
  - When to fail back the trampoline (ie, it's timeout time)

We need to be able to pull out of claimable payments the following:
- A generic success action (claim with preimage or forward trampoline)
- A generic failure action (timeout htlc or fail back incoming)

What does the receive branch do right now:
- Pulls out cltv_expiry, onion etc from `PendingHTLCRouting`
- Creates a `claimable_htlc`
- Checks that the payment preimage is known 
- Matches on `OnionPayload` and checks conditions
- Calls `check_total_value!` macro which will push it into
  `claimable_payments` if it's not ready, and push an event if it is
- `fail_htlc` pushes to `failed_forwards`, which will be passed back
  to `fail_htlc_backwards_internal` (where we have a trampoline check)

Failure case:
- If we don't have an outbound payment yet, we can fail back the
  incoming HTLCs
- Existing timeout logic:
  - `fail_htlc_backwards_with_reason`: need to disallow trampoline manual
    fail backs here.
  - `timer_tick_occurred`: If we have the full amount, we won't time out,
    and we'll only ever have outbound *if* we have the full amount.
  - `do_chain_event`: If our outgoing htlc is going to expire, we will
    fail it back.
- If we do have an outbound payment, we need to wait for a resolution
  there before we can fail the incoming htlcs back

Q: how does `fail_htlc_backwards_internal` work when we have outbound
   payments with different heights?
- Our failure logic only fails once all of the outbound HTLCs are done,
  so we must make sure we set sane CLTVs on our outbound so that we
  have a buffer from our soonest-expiring incoming HTLC.

Success case:
- `claim_funds_internal`: should only call this if we're ready for the
  trampoline to be fully claimed (?)

#### `impl_for_vec`?

`required_vec` -> doesn't need `impl_for_vec`
`required` -> *does* need `impl_for_vec`

`HTLCLocator`: 
- Written with required, so needed

`ChannelID`:
- Written with required, so needed

#### Persistence

- [x] Should `SentHTLCId` be even?
  Yes, we use it to claim money so we should fail if we don't understand
  what it is.

- [x] Should `HTLCHandlingFailed` trampoline type be odd?
  Seems so, it's just an event so we should be able to downgrade and
  just ignore this event? Also make the inner one odd so that we can
  be forwards compatible.
