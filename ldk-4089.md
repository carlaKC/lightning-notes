# Zero Fee Commitments Tests

## Set HTLC tx version 3 handling BumpTransactionEvent::HTLCResolution

- `handle_htlc_resolution`:
  - The specification notes that timeout and success txns should be
    V3 when we user `zero_fee_commitments`
  - We set sequence in `build_htlc_input` already

Q: Do we need to check size restrictions for these transactions?
- Right now we only broadcast our htlc transactions after a block has
  passed, so we don't run into package limits.

Q: Do weight limits apply to individual V3 transactions or just their
   children?
- https://github.com/bitcoin/bips/blob/87f3fe164484f73c30cdb122481bed96a1f79af9/bip-0431.mediawiki#specification
- There is a limit of 10,000 vb on single TRUC transactions

Q: Is it possible that we go over the limit by having 57 success txns?
- `OnchainTxHandler`'s `pending_claim_requests`:
  - Contains `PackageTemplate`: provides a list of inputs we should use
  - Where do we write to this?
    - `update_claims_view_from_requests`
    - `blocks_disconnected`

Focusing on `update_claims_view_from_requests`:
- Gets a set of `requests: Vec<PackageTemplate>`
  - Drop any duplicates
  - Combine any possible using `can_merge_with` 
  - Next we get everything that we can spend right now 
    (unencumbered + locked) 
  - Call `generate_claim` for the request
  - We then push it to our `pending_claim_requests`
  

Q: Can htlc transactions be merged? Yes!
- Malleable?
  - All htlcs in anchor channels are malleable
- Inputs empty?
- From same tx tree?
- Same locktime?
  - Always 0 for success, so trivially matches
  - Expiry height for timeout, so could match if expire at the same time
- Same pinning status?
  - This will be trivially true, since they're the same type of tx

Q: What type of requests do we get in `pending_claim_requests`?
Taking a look at all the places that we'll call this:

`provide_payment_preimage`:
- We provide a payment hash and preimage, plus MPP info if relevant
- Push the preimage to our set of known preimages
- Get the txid and height that the funding tx was spent, and its details
- If it is the counterparty's latest tx:
  - `counterparty_claimable_outpoints` has a list of the htlcs in tx
  - `claim_htlc!(counterparty_claimable_outpoints)`
    - `get_counterparty_output_claim_info`
      - For each of the HTLCs on the commitment we create either:
        - `CounterpartyOfferedHTLCOutput`
        - `CounterpartyReceivedHTLCOutput`
      - We then call `PackageTemplate::build_package` with the above,
        which become the `inputs` in our template
    - `update_claims_view_from_requests`
(ignoring the breach case for now)
- If it is our commitment transaction:
  - `get_broadcasted_holder_claims`:
    -  Iterate through each HTLC on our tx
    - `PackageTemplate::build_package` with `HTLCHolderOutput` 
  - `update_claims_view_from_requests` with claims


`block_confirmed`: probably does the same as above, just for timeout.

Stepping back to our high-level view:
- `rebroadcast_pending_claims`:
  - iterates through `pending_claim_requests`
    - `generate_claim` for each

I am missing the step between the bump request and going to chain, but
I believe (per comments on `HTLCResolution`) that we are aggregating
our htlc transactions.

## Adjust the weight of htlc success and timeout witnesses in 0FC channels

- We add constants to provide more accurate weight
- 0FC don't have a CSV1, so we're 3 weight units lower than anchors
  (these are the values that we have for regular non-anchor/old chans
    in the spec).

## Assert in tests that the witness spending a P2A anchor is empty

- Trivial, good assert

## Allow a single P2A output to be below dust in check_spends!

- Allows a single output to be dust 
- `check_spends!` takes a `tx` and its parent `spends_txn`
  - Goes through the outputs of the parent and asserts that it is
    all in order
    - If there are multiple dust outputs
    - If the sub-dust tx is not a P2A
- `do_check_spends`:
  - Takes the `tx` spending the parent
  - Runs checks on all of its outputs

Q: do we need this check in both `do_check_spends` and `check_spends!`?
- I think so?

## Add 0FC to the set of supported features in non-test builds

- Trivial

## Include 0FC channels in chan_utils::test_anchors

- Don't love this test's structure of just overloading a single thing,
  but it's fine
- We don't have any coverage on our actual anchors?

## Run async_signer_tests::test_async_holder_signatures with P2A anchors

- Updates signing to be a table test, nice

## Add coverage for 0FC channels in monitor_tests

Q: Why are we sometimes spending coinbase tx?
- Because our commitment spends it

## Add coverage for 0FC channels in `reorg_tests`

Q: why do we have: anchor -spends-> commitment ->spends -> coinbase
*and* anchor_tx -spends-> commitment -spends-> coinbase

`do_test_}etries_own_commitment_broadcast_after_reorg`:
- We create a network with two nodes in it
- `provide_anchor_reserves`:
  - Adds one BTC output to a transaction and minds a block paying them
- Create a channel between the two nodes
- Send a payment through them too, and get right up to the htlc expiry
- Check that the channel is force closed
- If there are anchors, we expect a bump that provides fees
- We then get the transactions that have been broadcast:
  - P2A:
    - anchor bump and commitment tx
    - assert that our commitment spends the funding tx
    - assert that the anchor spends the commitment tx and a coinbase to
      bump fees
- By contrast, anchors don't need to add a UTXO, they just spend the
  funding using the anchor value as fees

So, coinbase is a little muckily named, yes it is a coinbase but it's
rlly just our fee bumping utxo.

## Add 0FC case to functional_tests::test_multiple_package_conflicts

- Just adds zero fee and updates to use helper

## Add insane_zero_fee_channel_open test to exported tests

- Exporting tag that previously didn't work

## Add test_p2a_anchor_values_under_trims_and_rounds

- Create a channel between two nodes, push a bunch of payment amounts
  between them
