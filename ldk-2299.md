Didn't push temp file form work PC, creating this in the meantime.

`send_payment_for_trampoline_forward`
- Create a new payment secret for payment to next trampoline, and
  a recipient onion that just has a payment secret.
- We then query for a route to the destination.
- `add_new_pending_payment`:
  - Add an entry to `pending_outbound_payments`
  - Creates a `Retryable` payment
  - Generate the onion private keys for the chosen path
- `pay_route_internal`:
  - Performs some checks on the route
  - Calls `send_payment_along_path` which actually dispatches
  - `handle_pay_route_err` will perform any state updates needed
    if we can't dispatch the payment
  - We return an appropriate error for the payment

- [x] Added validation to `send_payment_internal` to make sure we only
  have forwarding fields in the payload.

- [x] Moving up `send_payment_along_path` change so that it's usable
  before our trampoline send commit.

- Creates a session private key for the payment being dispatched
- Create an `onion_packet, htlc_msat, htlc_cltv` for the info (1)
- Gets the channel we're sending over
- Creates the HTLC source (using `previous_hop_data` that we put in
  `trampoline_forward_info`.
- `send_htlc_and_commit` to dispatch the HTLC
- Does all the regular error handling 

(1) `create_trampoline_forward_onion`
- Creates an outer onion which pays the final amount in the path
  to the trampoline node that's receive it
- [ ] Takes a `keysend_preimage` that we shouldn't have?
- Builds the onion path for the outer onion using `final_value_msat`
- Creates recipient data for the trampoline
- Looks at the last onion paylaod we've created (must be a receive)
  - If unblinded, we add `TrampolineEntrypoint`
  - If blinded, we add `BlindedTrampolineEntrypoint`
- We overwrite the `last_payload`
- Finally, create onion keys and packet with the path and onion
  payloads provided

Q: what's the difference between `path.final_value_msat` and the 
  `total_msat` that's passed in here?
Q: would we ever pass in a `keysend_preimage` here?

(1) `create_payment_onion` (calls straight to `create_payment_onion_internal`:
- If there is a blinded tail
  - If there are trampoline payments
  - `build_trampoline_onion_payloads`
  - Create session private keys for trampoline
  - Construct onion keys for trampoline
  - Create onion packets for trampoline w/ keys
- `build_onion_payloads`
- Finally, construct onion keys and onion packet and payloads

- [ ] Issue:
- When we're the ones to build the trampoline payloads, we only
  support them if they're blinded
- When we receive the already built payload in a forwarding scenario,
  we have to cover both cases.

Going back to look into the payload types we support, I don't love the
claude suggestion for refactor here.

The types of outer onions we receive `InboundOnionPayload`:
- `Forward`: regular, no blinding
- `TrampolineEntrypoint`:
  - Could have `FinalOnionHopData` if if we've been MPP-ed to
  - Contains an inner onion packet (which we unwrawp)
  - `current_path_key`: we need to include this for the next node to
    unwrap their trampoline onion
  -> Basically, end of the outer onion time to do trampoline
- `Receive`: regular receive
- `BlindedForward`: blinded forwarding node gets routing info
- `BlindedReceive`: blinded recipient gets receive info

Types of inner trampoline onions we receive:
- `Forward`: we've been given the next node id to forward to
- `BlindedForward`: we're forwarding and get our routing info out of
  an encrypted data blob.
- `Receive`: we're the final recipient, but we looked like a trampoline
  to the previous node.
- `BlindedReceive`: we're the final recipient, and we got our recipient
  information out of encrypted data.

The types of ourter onions we create `OutboundOnionPayload`:
- `Forward`: regular forwading hop
- `TrampolineEntrypoint`: this is a trampoline and it gets the inner
  onions in its payload.
- `BlindedTrampolineEntrypoint`: this is a trampoline and it gets
  inner onions in its payload, along with a blinding point to help
  decrypt the inner onions.
- `Receive`:  regular receive
- `BlindedForward`: include encrypted tlvs for this node which has the
  forwarding information that it needs.
- `BlindedReceive`: was part of a blinded route, include final info 

The types of inner onions we create: `OutbountTrampolinePayload`:
- `Forward` + `Receive` regular fwd/recv inter-trampoline
  - Note: we don't support receiving unblinded
- `LegacyBlindedPathEntry`: end of trampoline, can send to blinded paths
- `BlindedForward`: include encrypted tlvs for node to get fwd info
- `BlindedReceive`: was part of a blinded route, include final info

Going back to our problem:
- `create_payment_onion_internal`:
  - Will create trampoline onions _if_ we have them in a blinded tail
  - Builds outer onion which will have these trampoline payloads in the
    last hop.

- `create_trampoline_forward_onion`:
  - Builds outer onion with the trampoline onion packet, creating a
    fake recipient onion for the final node
  - Gets the last onion payload that we've just built, which is a
    regular receive onion
    - Replaces it with either a `TrampolineEntrypoint` or a
      `BlindedTrampolineEntrypoint`

Q: Why can't we have trampoline packets in our path for inter-trampoline?
- We're picking a destination, and we don't have a blinded path from
  them to pay to.
- If we're a trapoline paying to a blinded path we have a
  `LegacyBlindedPathEntry` which isn't dealt with as a forwad (?)

Q: What are all the different case we need to handle?

Sending:
- Last trampoline is recipient:
  - Unblinded: sender includes final hop details in trampoline onion
  - Blinded: sender includes encrypted data in trampoline onion
- Exit to blinded path:
  - Sender receives a blinded path
  - Instructs last trampoline to route to introduction node
  - Puts blinded path information inside of subsequent trampoline
    payloads (blinded forward + blinded receive).

`build_onion_payloads_callback`:
- If we have `BlindedTailDetails::DirectEntry`:
  - Create a blinded receive at the end of the route
  - Create blinded forwards up until it, providing blinding point to
    the first one (the introduction node)
- If we have `BlindedTailDetails::TrampolineEntry`:
  - If there's a blinding point present, create `BlindedTrampolineEntrypoint`
  - Otherwise create `TrampolineEntrypoint`

Key difference:
- `DirectEntry`: we're just using a blinded path, and we should push
  multiple hops into our path for blinded forwards.
- `TrampolineEntry`: we're using trampoline forwading, and should push
  a trampoline onion which has already wrapped each of our blinded
  payloads in subsequent inner onions.

Note: LDK only supports the case where we're given a blinded path and
put the information inside of the trampoline onions, using each hop as
a blinded trampoline.

Thoughts:
- We should just be able to provide the right type of iter and we'll be
  fine? When we have a pre-built trampoline packet it's just a
  TrampolineEntrypoint?
- we need to call `build_onion_payloads_callback` with a TrampolineEntrypoint

Forwarding:
- When we receive a payload with a trampoline onion inside of it, we
  decode the inner onion and distinguish between the following:
  - `TrampolineForward`: given pubkey of next node
  - `BlindedFoward`: given forwarding details inside of blinded data
  - `Receive`: we're receiving and the person who sent knows it
  - `BlindedRecieve`: we've received via a blinded path
  - We fail if:
    - We get a forward with no next hop data
    - We get a receive with next hop data
- Regardless of whether we got a `TrampolineForward` or a
  `TrampolineBlindedForward`, we'll create `NextPacketDetails` with
  the pubkey of the next node in it.

Note: LDK doesn't currently support the case where you just throw some
blinded paths into the *outer* onion and then make a payment to them.
This is a workaround for when the recipient doesn't support trampoline.
I'm not sure whether we need to do this?

Note: For now, I'm going to ignore the above case and just work with
the "everyone supports trampoline" case.

Issue:
- We only add a `TrampolineEntry` if we've got a blinded path and there
  is Some `trampoline_packet`.
- For forwading, we may have a `trampoline_packet` which doesn't have
  any blinded path attached to it.

Q: I think that pairing the blinded path with trampoline was a mistake
that comes from only wanting to support them together in receives?
- In a world where 

## ln: handle trampoline without validating in process pending

It's okay to not process because they'll go from here to process
receives.

## Incoming HTLC Accumulation

We need to accumulate in the same way that we do for MPP payments.
- `process_receive_htlcs` is the starting point for all of this
- This will be called for _every_ incoming trampoline HTLC that arrives.

What does this do:
- Go through each pending_forward
- Match on the type 
- Creates a ClaimableHTLC struct
- Starts to track `committed_to_claimable` 
- Check if we konw the preimage, otherwise set to None
- Match on the `onion_payload` type to do checking for the
  specific type of receive (eg, check payment data, validate)
- Call `check_total_value`
 - Fail if we currently have a pending claim
 - Add to `claimable_payemnts`, noting if we're already
   `committed_to_claimable` (ie, an entry is already there)
  - Check that onion fields are the same 
  - Check the total amount on the HTLC is satisfied
    - Push to `claimable_payments` if it is ok
    - Pushes an event

What do we need to change:
- Add matching for trampoline payment
- Add an onion type (if avoid if we can) for trampoline
- Add a payment purpose for trampoline
- When we're fully accumulated, we should dispatch the payment

Q: what do we do with `pending_claimable`?

Breaking up what we have:
`outbound_payments`
- Add to `pay_route_internal`
- Add to `create_pending_payment`
- Add to `PendingOutbound`
- `send_payment_for_trampoline`
- `trampoline_htlc_failed` 

`channelmanager`
- `send_payment_along_path`:
  - creates onion for trampoline or payment
  - creates source accordingly
- `process_pending_update_add_htlcs`:
  - Adds trampoline to validation (but doesn't check it)
- `process_receive_htlcs`:
  ! This is what's going to need to change when we add accumulation !
  ! We still want all of this logic, but we need to call it after acc !
  - Processed blinding point
  - Calculates fees for trampoline
  - Setup parameters for trampoline payment
  - `send_payment_for_trampoline_forward` 
- `fail_backwards_internal`:
  - checks in with `outbound_payments` that we should actually fail back

Differences:
- Trampoline isn't a `ClaimablePayment`, we need the fields:
  - `fail_htlc` needs:
    - value
    - prev_hop
    - Need to push a HTLCSource (which isn't outbound payment)
  - `check_total_value` needs:
    - Purpose
    - Whether to push to claimable_payments or trampoline?
    - We want to merge onion fields (checks MPP data)
    - We need different actions on success (push event vs dispatch)
- Also want to have a pending trampoline mitigation

`check_claimable_payment`:

Q: Can we represent trampoline in `ClaimablePayment`?
- `prev_hop`: yes? can be represented by each one of the tram incoming?
- expiry + value + sender_intended_value: should all be good
- `OnionPayload`: need to add an option for trampoline
- timer_ticke/total_receives/total_msat: all should be fine?

Q: How can we handle locking? We need to hold `pending_outbound_payments`
   _before_ we hold `claimable_payments`

Action:
- Return a result with the `ClaimablePayment`, `amount_msat`, `earliest_expiry`
- Perform the success closure w/o holding the lock (?)

Note:
- Pulling out claimable_payments helper doesn't need to separate the
  guard because we're going to use a separate lock
- Make a macro for adding to timed_out_htlcs

Things we need that `claimable_payment` doesn't have:
- `incoming_trampoline_shared_secret`:
- `path`:
- `session_priv`:
- `payment_id`

For trampoline:
- We'll only have payments in this map if it's pending accumulation
- Once we've dispatched the payment we must remove it from the map.
  - On restart, we need to trim any pending things that might be waiting
- When we hit timeout, we should just fail everything back to keep it
  simple.
  - MPP: fail everything back
  - On chain: fail everything back

Trampoline will *wrap* claimable payment!

Q: Are we happy to fail all htlcs backwards when a trampoline payment
   has hit an expiry height.
  - Yes, we don't care

Q: Make HTLCSource's path option or move it?
- `send_payment_along_path`: path is passed in
  - `pay_route_internal`: we dispatch along each path, and store the
    high level route in the payment.
- `trampoline_htlc_failed`?
- `process_onion_failure`:
  - `process_onion_failure_inner` Q: do we have otherwise at inner
    - Needs `path` for attributable errors
- `decode_onion_failure`:
  - Ultimately needs to get path from source
-> This does seem to be like it belongs in `HTLCSource::TrampolineForward`,
   so will make it an option

Fields we need to check incoming trampoline:
- cltv_expiry: easy, we have this in PendingHTLCRouting
- onion_payload:
  - We should be getting `payment_secret` and `total_amount` from
    the *outer* onion when we receive a trampoline payment (if it
    is present, it doesn't need to be if it's not MPP)
  - [ ] We need to add this and propagte it through to reach recieves 
- 

- payment_data,
- payment_context,
- phantom_shared_secret: should be non
- onion_fields:
- has_recipient_created_payment_secret: false
- invoice_request_opt: false (?)
- trampoline_shared_secret: Some(?)

Q: what's the difference between `FinalOnionHopData` and `OnionPayload`?
- `onion_payload`: included in `ClaimablePayment`, used to pick purpose
- `payment_data`: used to set `total_msat` on `ClaimableHTLC`

## Graveyard

This is the old handling code that would forward immediately.

```
	fn process_receive_htlcs(
		&self, pending_forwards: &mut Vec<HTLCForwardInfo>,
		new_events: &mut VecDeque<(Event, Option<EventCompletionAction>)>,
		failed_forwards: &mut Vec<FailedHTLCForward>,
	) {
		'next_forwardable_htlc: for forward_info in pending_forwards.drain(..) {
			match forward_info {
				HTLCForwardInfo::AddHTLC(PendingAddHTLCInfo {
					prev_outbound_scid_alias,
					prev_htlc_id,
					prev_channel_id,
					prev_funding_outpoint,
					prev_user_channel_id,
					prev_counterparty_node_id,
					forward_info:
						PendingHTLCInfo {
							incoming_shared_secret: incoming_outer_shared_secret,
							payment_hash,
							incoming_amt_msat,
							outgoing_amt_msat,
							outgoing_cltv_value,
							routing:
								PendingHTLCRouting::TrampolineForward {
									incoming_shared_secret: incoming_trampoline_shared_secret,
									node_id: next_node_id,
									ref onion_packet,
									blinded,
									incoming_cltv_expiry,
									..
								},
							..
						},
				}) => {
					let htlc_source = HTLCSource::TrampolineForward {
						// dummy value
						session_priv: SecretKey::from_slice(
							&self.entropy_source.get_secure_random_bytes(),
						)
						.unwrap(),
						previous_hop_data: vec![HTLCPreviousHopData {
							prev_outbound_scid_alias,
							user_channel_id: Some(prev_user_channel_id),
							counterparty_node_id: Some(prev_counterparty_node_id),
							channel_id: prev_channel_id,
							outpoint: prev_funding_outpoint,
							htlc_id: prev_htlc_id,
							incoming_packet_shared_secret: incoming_outer_shared_secret,
							// Phantom payments are only PendingHTLCRouting::Receive.
							phantom_shared_secret: None,
							trampoline_shared_secret: Some(incoming_trampoline_shared_secret),
							blinded_failure: blinded.map(|b| b.failure),
							cltv_expiry: Some(incoming_cltv_expiry),
						}],
						incoming_trampoline_shared_secret,
						path: Path { hops: vec![], blinded_tail: None }, // TODO: fill values!
						payment_id: PaymentId(payment_hash.0),
					};

					let mut push_trampoline_forwarding_failure =
						|msg: String,
						 htlc_source: HTLCSource,
						 _forward_scid: Option<u64>,
						 reason: LocalHTLCFailureReason,
						 err_data: Vec<u8>| {
							let logger = WithContext::from(
								&self.logger,
								Some(next_node_id),
								Some(prev_channel_id),
								Some(payment_hash),
							);
							log_info!(
								logger,
								"Failed to forward incoming Trampoline HTLC: {}",
								msg
							);

							failed_forwards.push((
								htlc_source,
								payment_hash,
								HTLCFailReason::reason(reason, err_data),
								HTLCHandlingFailureType::TrampolineForward {
									attempted_htlcs: vec![], // TODO: fill these in
								},
							));
						};

					let next_blinding_point = blinded.and_then(|b| {
						b.next_blinding_override.or_else(|| {
							let encrypted_tlvs_ss = self
								.node_signer
								.ecdh(Recipient::Node, &b.inbound_blinding_point, None)
								.unwrap()
								.secret_bytes();
							onion_utils::next_hop_pubkey(
								&self.secp_ctx,
								b.inbound_blinding_point,
								&encrypted_tlvs_ss,
							)
							.ok()
						})
					});

					let incoming_amount = match incoming_amt_msat {
						Some(amount) => amount,
						None => {
							push_trampoline_forwarding_failure(format!("Missing incoming amount to calculate routing parameters to next Trampoline hop {next_node_id}"), htlc_source, None, LocalHTLCFailureReason::TemporaryTrampolineFailure, Vec::new());
							continue;
						},
					};

					let (forwarding_fee_proportional_millionths, forwarding_fee_base_msat) = {
						let config = self.config.read().unwrap();
						(
							config.channel_config.forwarding_fee_proportional_millionths,
							config.channel_config.forwarding_fee_base_msat,
						)
					};
					let proportional_fee = forwarding_fee_proportional_millionths as u64
						* outgoing_amt_msat / 1_000_000;
					let forwarding_fee = proportional_fee + forwarding_fee_base_msat as u64;
					let cltv_expiry_delta = incoming_cltv_expiry - outgoing_cltv_value;

					let max_total_routing_fee_msat = match incoming_amount
						.checked_sub(forwarding_fee + outgoing_amt_msat)
					{
						Some(amount) => amount,
						None => {
							push_trampoline_forwarding_failure(format!("Insufficient fee to forward to the next Trampoline hop {next_node_id}"), htlc_source, None, LocalHTLCFailureReason::TrampolineFeeOrExpiryInsufficient, Vec::new());
							continue;
						},
					};

					// Assume any Trampoline node supports MPP
					let mut recipient_features = Bolt11InvoiceFeatures::empty();
					recipient_features.set_basic_mpp_optional();

					let route_parameters = RouteParameters {
						payment_params: PaymentParameters {
							payee: Payee::Clear {
								node_id: next_node_id,
								route_hints: vec![],
								features: Some(recipient_features),
								final_cltv_expiry_delta: 4,
							},
							expiry_time: None,
							max_total_cltv_expiry_delta: cltv_expiry_delta,
							max_path_count: DEFAULT_MAX_PATH_COUNT,
							max_path_length: MAX_PATH_LENGTH_ESTIMATE / 2,
							max_channel_saturation_power_of_half: 2,
							previously_failed_channels: vec![],
							previously_failed_blinded_path_idxs: vec![],
						},
						final_value_msat: outgoing_amt_msat,
						max_total_routing_fee_msat: Some(max_total_routing_fee_msat),
					};

					#[cfg(not(any(test, feature = "_test_utils")))]
					let retry_strategy = Retry::Attempts(3);
					#[cfg(any(test, feature = "_test_utils"))]
					let retry_strategy = Retry::Attempts(0);

					let result =
						self.pending_outbound_payments.send_payment_for_trampoline_forward(
							PaymentId(payment_hash.0),
							payment_hash,
							TrampolineForwardInfo {
								next_hop_info: NextTrampolineHopInfo {
									onion_packet: onion_packet.clone(),
									blinding_point: next_blinding_point,
								},
								previous_hop_data: vec![HTLCPreviousHopData {
									prev_outbound_scid_alias,
									user_channel_id: Some(prev_user_channel_id),
									counterparty_node_id: Some(prev_counterparty_node_id),
									channel_id: prev_channel_id,
									outpoint: prev_funding_outpoint,
									htlc_id: prev_htlc_id,
									incoming_packet_shared_secret: incoming_outer_shared_secret,
									// Phantom payments are only PendingHTLCRouting::Receive.
									phantom_shared_secret: None,
									trampoline_shared_secret: Some(
										incoming_trampoline_shared_secret,
									),
									blinded_failure: blinded.map(|b| b.failure),
									cltv_expiry: Some(incoming_cltv_expiry),
								}],
								incoming_trampoline_shared_secret,
							},
							retry_strategy,
							route_parameters.clone(),
							&self.router,
							self.list_usable_channels(),
							|| self.compute_inflight_htlcs(),
							&self.entropy_source,
							&self.node_signer,
							self.current_best_block().height,
							&self.pending_events,
							|args| self.send_payment_along_path(args),
						);

					if let Err(retryable_send_failure) = result {
						push_trampoline_forwarding_failure(
							format!("Trampoline send failure {:?}", retryable_send_failure),
							htlc_source,
							None,
							LocalHTLCFailureReason::TemporaryTrampolineFailure,
							Vec::new(),
						);
					};
				},
```
