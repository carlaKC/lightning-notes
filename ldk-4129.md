# Batching V3 HTLC Claims

## Review Pass 1

### Implement Holder HTLC claim chunking for 0FC channels

`unsigned_tx_weight` = `htlc_tx.to_wu() - (htlc_tx.input_len() * EMPTY_SCRIPT_SIG)`
Q: why do we subtract EMPTY_SCRIPT_SIG off the weight?
- They're replaced by the witness on signing

Q: Can we hit the `batch_size.checked_sub(htlcs_to_remove)`?
- Only if we have a really small number of htlcs left to remove, and
  in that case we're not going to hit the weight limit

- We no longer pass the `claim_id` into `handle_htlc_resolution` because
  we're going to make it inside the function where we do batching.
- We move the transaction creation and accumulation of `must_spend`
  down

Q: Is the 703 double counting the transaction overhead?
- Looks like it to me (version etc included here).

Create a loop that will run until the number of htlcs we've broadcast
is less than our total count.

Eg, start with 105 HTLCs.
Let's assume that 50 will fit in a batch.
- 40,000 wu total
- 50x htlcs @ 703 = 35150 
- Coin selection = 4850 wu to allow 50 htlcs

`broadcasted_htlcs` = 0;
`batch_size` = 105;
`htlcs` = `htlc_descriptors[0, 105]`

We run coin selection with all 105 htlcs.
- 105 htlcs @ 703 = 76650
- inputs @ 4850
= 81500

= 41500 extra (ignoring signatures for now)

(assuming that we're using htlc success for removal):
HTLCs to remove = (41500 / 703 + 2)
= 61 HTLCs

`batch_size` = 105 - 61 = 44
continue

`broadcasted_htlcs` = 0
`batch_size` = 44
`htlcs` = `htlc_descriptors[0,44]`

We run coin selection with 44 htlcs:
- 44 htlcs @ 703 = 30932
- inputs @ 4850
= 35,782

This will fit in our limit!

`broadcasted_htlcs` = 44
`batch_size` = 105 - 44 = 61
`htlcs` = `htlc_descriptors[44, 105]`

We run coin selection with 61 htlcs:
- 61 htlcs @ 703 = 42883
- inputs @ 4850
- 47733

This will not fit in our batch:
- Extra = 7733
- HTLCs to remove = (7733 / 703 + 2) = 13

`batch_size` = 61 - 13 = 48
`broadcasted_htlcs` = 44
`htlcs` = `htlc_descriptors[44, 44 + 48]` 

We run coin selection with 48 htlcs:
- 48 htlcs @ 703 = 33744
- inputs @ 4850
- 38594

This will fit in our limit!

`broadcasted_htlcs` = 44 + 48 = 92
`batch_size` = 105 - 92 = 13
`htlcs` = `htlc_descriptors[92, 92*13]`

We run coin selection with 13 htlcs:
- 13 htlcs @ 703
- inputs @ 4850

This will fit in our limit!
`broadcasted_htlcs` = 93 + 13 = 105

Our while loop will break and we're done!

Core logic looks good, give or take some nits, just need to review the
test.

`test_htlc_clain_chunking`:
- Setup 2 nodes, both accepting zero fee comms
- Fund them with a UTXO that they can use for bumping
- Create a zero fee commitment channel between them
- Create 75 htlcs on their commitment
- Claim the HTLCs on the receiver, clear any messages they'd want to
  exchange to update commitment
- Mine the commitment transaction that has the htlcs on it 
- Get the bump event on the claiming node and handle it
- Assert that we split up our HTLC claims
- Mine the first bump, but not the second one
- Assert that we'll bump the remaining 17

LGTM!

## Review Pass 2

### fixup: Use the weight of the single input-output pair, not the full tx

- Use constants?
- I do think we can only trigger on >, but not blocking

### fixup: remove unused vars in tests

- gg

### fixup: cap aggregation of HTLCs in anchors_zero_fee_htlc_tx channels …

- Looks good, nice comment

### fixup: allocate a USER_COINS_WEIGHT_BUDGET when selecting HTLCs in …

- We set a `USER_COINS_WEIGHT_BUDGET` of 1000 wu
- No longer generate `claim_id` beforehand
- Create a `must_spend` vector that can hold the full number of htlcs
  that we have left to broadcast
- Add the next htlc, and get its weight and check that it won't run
  over the max less the budget
- We then push into the must spend vecs
- Use the original claim id if we're running with the first one,
  otherwise generate a new `claim_id` 
  - It is nice that we get to use the `claim_id` that the event has
    at least for the first in the batch

### fixup: Asset TRUC transactions are below 10_000 WU in check_spends

- In test that check all the txns we're making!

### fixup: Add ClaimId::from_htlcs

- Adds requested function, nice

### Remainder

Other commits small fixups from previous comments.

## Review Pass 3

Going through the fixups on the original change first, then will
take a final whole change look squashing them.

### fixup! Implement Holder HTLC claim chunking for 0FC channels

- API for `select_confirmed_utxos`: it seems that `max_tx_weight`
  could also be `Option`, and inferred to be standard relay limit
  when not set
- Not being an option saves every impl from having to `unwrap_or`, so
  it seems fine.

This commit just adds a comment:
- Saying exactly when we will re-call the API on the trait definition
  (`rebroadcast_pending_claims`) is a bit strange to me, but it doesn't
  seem like the time for nits.

### f: Use bitcoin::policy::MAX_STANDARD_TX_WEIGHT

Q: should our api's weight limit be a u32 like in bitcoin crate?
- We do weights as u64 all over the place, so doesn't make sense
- Added a comment but I don't think it's worth changing

### f: Rename to aggregated_htlc_timeout_input_output_pair_weight

- Just renames the function + clarifies the doc
Q: I don't really understand why this is prefixed with `aggregated`,
   because `inputs_output_pair` makes it clear to me that this is
   not including the transaction overhead (ie, old name seemed fine).
   No strong feelings. 

### f: Trim down coin selection if possible after meeting requirements

This is a change to the default `select_confirmed_utxos` impl:

Recap of how this works:
- Track our `selected_amount` / `total_fees` / `selected_utxos` 
- Lock our set of `locked_utxos` that we're currently using
- Go through the set of `Utxo`s that we've been given, filtering out:
  - Those already in use, unless we're forcing reuse
  - If the fee to spend them is too high of a portion of the amount
- Sort utxos by their effective value (once fee to spend them is counted),
  smallest to largest
- `selected_amount` = `input_amount_sat` (provided)
- `total_fees` = `fee_for_weight(feerate, preexisting_tx_weight)`
- `selected_utxos_weight` = `0` 
- Loop through eligible utxos:
  - Break if `selected_amount >= target_amount_sat + total_fees` and
    `selected_utxos_weight <= max_utxo_selection_weight`
  -> We don't break if we're at the right amount but we're over the
     total limit
  - If we're over the weight limit, trim back the first utxo added
    and remove it from our `selected_amount` and `selected_utxos_weight`
    (this trims off small utxos that push us over the weight limit)
    Q: does this also stop us from selecting coins when we have them?
- If we're not at the amount we need, or we're over weight once we've
  been through all of the utxos we have, then we error out
- Once we've selected utxo that give us the amount we need:
  - Pop the front selected utxo (smallest one)
  - Check if we can live without it (in terms of amount)
  - If so, we remove it

Q; Could we live with just one loop?
- First cleanup: select utxos until we have the amount we want, then
  see if we can trim off any of the smaller ones that might be adding
  weight but not that much (subsequent, larger htlcs got us there anyway)
- Second cleanup: we managed to get to our target amount and weight, is
  there any small utxo that we could shave off once we've gotten there

### f: Don't pull a change script unless necessary

- Instead of just pulling a change address, we subtract the weight
  of our expected change address.

### f: Rework claim_id assignments

- Adds data to `ClaimId`
- Just add the `broadcasted_htlcs` size to the `claim_id`, these can't
  be duplicate because we're always increasing this number per batch
  but we are re-using the original `claim_id` for coin selection

### f: Log the max_coin_selection_weight upon failure

Logs!

### f: Add the commitment tx weight on top of the max weight of the child

Q: can this go over the max weight?

### f: Stop trimming HTLCs from claim once batch_size is 0

- Exits if we hit a batch size of 0, theoretically prevents inf loop

### f: Rename and move constants

Refactor, looks good.
